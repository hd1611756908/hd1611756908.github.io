<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MQTT协议快速入门</title>
    <url>/2024/05/05/MQTT%E5%8D%8F%E8%AE%AE%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者: 夜泊1990</span><br><span class="line">企鹅: 1611756908</span><br><span class="line">鹅群: 948233848</span><br><span class="line">邮箱: hd1611756908@163.com</span><br><span class="line">博客: https://hd1611756908.github.io/</span><br><span class="line">B 站: https://space.bilibili.com/514155929/</span><br></pre></td></tr></table></figure>

<h2 id="第一章-MQTT协议概述"><a href="#第一章-MQTT协议概述" class="headerlink" title="第一章 MQTT协议概述"></a>第一章 MQTT协议概述</h2><h3 id="第1节-MQTT协议介绍"><a href="#第1节-MQTT协议介绍" class="headerlink" title="第1节 MQTT协议介绍"></a>第1节 MQTT协议介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MQTT是一种基于发布/订阅模式的轻量级消息传输协议，设计用于低带宽、高延迟或不稳定的网络环境，广泛应用于物联网领域</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="第2节-MQTT协议版本更迭"><a href="#第2节-MQTT协议版本更迭" class="headerlink" title="第2节 MQTT协议版本更迭"></a>第2节 MQTT协议版本更迭</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1999年    MQTT v1.0 由IBM Andy Stanford-Clark和Eurotech的Arlen Nipper为石油管道远程监控项目发明的</span><br><span class="line">2010年    MQTT v3.1 IBM将 MQTT v3.1版本协议开放给所有人使用</span><br><span class="line">2014年10月 MQTT v3.1.1 MQTT正式成为OASIS标准                   --当前主流版本</span><br><span class="line">2019年03月 OASIS发布了 MQTT v5.0 5.0版本成为了OASIS的新的标准     -- 后起之秀版本</span><br></pre></td></tr></table></figure>

<h3 id="第3节-MQTT协议的应用场景"><a href="#第3节-MQTT协议的应用场景" class="headerlink" title="第3节 MQTT协议的应用场景"></a>第3节 MQTT协议的应用场景</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. 智能家居       : MQTT可以用于连接各种家电设备和传感器，实现设备之间的通信和控制</span><br><span class="line">2. 车联网         : MQTT可以用于车辆与车辆、车辆与基础设施之间的实时通信</span><br><span class="line">3. 工业物联网     : MQTT可以用于连接各种工业设备和传感器，实现设备的监测和控制</span><br><span class="line">4. 远程监控和控制  : MQTT可以用于将传感器数据发布到云平台，供其他设备或应用程序订阅和使用</span><br><span class="line">5. 消息通知       : MQTT可以用于提供实时消息通知功能</span><br><span class="line">6. 资源监控与管理  : MQTT能够提供对物联网设备的实时监控和管理功能</span><br><span class="line">7. 数据采集和分析  : MQTT也可以用于数据采集和分析</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf5f1ada649a28c320db46217fc5e4bb6?method=download&shareKey=5aec6bfe86acba0df47948c623b1edbc" alt="MQTT能力"></p>
<h3 id="第4节-MQTT协议优势"><a href="#第4节-MQTT协议优势" class="headerlink" title="第4节 MQTT协议优势"></a>第4节 MQTT协议优势</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 常见的计算机语言(C/C++、Java、Python、Go...)都有支持MQTT协议的客户端</span><br><span class="line">2. MQTT协议是建立在TCP/IP协议基础之上,所以MQTT协议安全可靠</span><br><span class="line">3. 服务质量设置，MQTT协议提供了三种服务质量配置分别为:</span><br><span class="line">	Qos 0: 消息可能丢失 </span><br><span class="line">	Qos 1: 消息不会丢失,但是可能重复</span><br><span class="line">	Qos 2: 消息不会丢失也不会重复</span><br><span class="line">4. 心跳保活: 由于网络问题可能造成连接陷于假死状态,为了判断客户端和代理是否出现异常，MQTT定义自己的心跳机制，定期向代理发送报文，以便于快速识别出异常连接，让客户端快速与代理断开连接</span><br><span class="line">5. 持久会话: 代理保留客户端发送过来的消息，以便于消息订阅端上线立刻获取消息</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h3 id="第5节-MQTT协议报文"><a href="#第5节-MQTT协议报文" class="headerlink" title="第5节 MQTT协议报文"></a>第5节 MQTT协议报文</h3><h4 id="5-1-报文-数据包-结构"><a href="#5-1-报文-数据包-结构" class="headerlink" title="5.1 报文(数据包)结构"></a>5.1 报文(数据包)结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MQTT报文(数据包)由三部分组成:</span><br><span class="line">1. 固定报头(Fixed header)    : 所有数据包中都包含此报头,用来表示数据包的类型,以及数据包的分组累标识</span><br><span class="line">2. 可变报头(Variable header) : 存在于部分MQTT数据包中,数据包类型决定了可变头是否存在及其具体内容</span><br><span class="line">3. 有效载荷(Payload)         : 存在于部分MQTT数据包中,表示客户端收到的具体内容</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1cfb82320eec5fcc9bb37ccb79992517?method=download&shareKey=d1b7ba2a4ab5fd51216da8d8e69f8555" alt="baowen"></p>
<h4 id="5-2-固定报头格式-Fixed-header"><a href="#5-2-固定报头格式-Fixed-header" class="headerlink" title="5.2 固定报头格式(Fixed header)"></a>5.2 固定报头格式(Fixed header)</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB25ef81539ff6766878d259f26bd9ef68?method=download&shareKey=b2de947188cdf5039cf1c24f6f71aae2" alt="mqtt"></p>
<h5 id="5-2-1-固定报头介绍"><a href="#5-2-1-固定报头介绍" class="headerlink" title="5.2.1 固定报头介绍"></a>5.2.1 固定报头介绍</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先固定报头一定存在所有的数据包中,也就是说在客户端与服务器端进行通信时,传递的所有消息中都包含固定报头</span><br><span class="line">那么固定报头主要是做什么的呢?</span><br><span class="line">举例说明：假如客户端向服务器端发送一个请求，那么问题来了，服务器端怎么判断客户端发送的这个请求是什么类型的请求，要给服务器传递数据呀，还是只是来判断服务器是否存活，还是想和服务器断开连接的请求，所以固定报头里面就保存了客户端向服务器端发送请求的类型，也就是上图中所谓的MQTT报文类型(占据byte1的高4位). byte1还有低4位，取值范围也是0-15，但是基本都是保留位,只有当MQTT的高4位类型是PUBLISH的时候，byte1的低4位取值才有意义,下面会详细介绍</span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-固定报头格式介绍"><a href="#5-2-2-固定报头格式介绍" class="headerlink" title="5.2.2 固定报头格式介绍"></a>5.2.2 固定报头格式介绍</h5><blockquote>
<p>byte1 高4位 MQTT报文类型介绍</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte1的高4位取值范围:</span><br><span class="line">二进制: 0000~1111</span><br><span class="line">十进制: 0-15</span><br><span class="line"></span><br><span class="line">具体每一个值对应的格式详细如下</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>报文类型名称</th>
<th>报文类型对应值</th>
<th>报文表示的意义</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Reserved</td>
<td>0</td>
<td>禁止</td>
<td>保留位</td>
<td>默认值 高4位 取值 0000</td>
</tr>
<tr>
<td>CONNECT</td>
<td>1</td>
<td>客户端到服务端</td>
<td>客户端请求连接服务端</td>
<td>高4位 取值 0001</td>
</tr>
<tr>
<td>CONNACK</td>
<td>2</td>
<td>服务端到客户端</td>
<td>连接报文确认</td>
<td>高4位 取值 0010</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>3</td>
<td>两个方向都允许</td>
<td>发布消息</td>
<td>高4位 取值 0011</td>
</tr>
<tr>
<td>PUBACK</td>
<td>4</td>
<td>两个方向都允许</td>
<td>QoS 1消息发布收到确认</td>
<td>高4位 取值 0100</td>
</tr>
<tr>
<td>PUBREC</td>
<td>5</td>
<td>两个方向都允许</td>
<td>发布收到（保证交付第一步）</td>
<td>高4位 取值 0101</td>
</tr>
<tr>
<td>PUBREL</td>
<td>6</td>
<td>两个方向都允许</td>
<td>发布释放（保证交付第二步）</td>
<td>高4位 取值 0110</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>7</td>
<td>两个方向都允许</td>
<td>QoS 2消息发布完成（保证交互第三步）</td>
<td>高4位 取值 0111</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>8</td>
<td>客户端到服务端</td>
<td>客户端订阅请求</td>
<td>高4位 取值 1000</td>
</tr>
<tr>
<td>SUBACK</td>
<td>9</td>
<td>服务端到客户端</td>
<td>订阅请求报文确认</td>
<td>高4位 取值 1001</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>10</td>
<td>客户端到服务端</td>
<td>客户端取消订阅请求</td>
<td>高4位 取值 1010</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>11</td>
<td>服务端到客户端</td>
<td>取消订阅报文确认</td>
<td>高4位 取值 1011</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>12</td>
<td>客户端到服务端</td>
<td>心跳请求</td>
<td>高4位 取值 1100</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>13</td>
<td>服务端到客户端</td>
<td>心跳请求</td>
<td>高4位 取值 1101</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>14</td>
<td>客户端到服务端</td>
<td>客户端断开连接</td>
<td>高4位 取值 1110</td>
</tr>
<tr>
<td>Reserved</td>
<td>15</td>
<td>禁止</td>
<td>保留位</td>
<td>高4位 取值 1111</td>
</tr>
</tbody></table>
<blockquote>
<p>byte1 低4位MQTT其他配置介绍</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte1 低4位默认大多都是保留位,没有意义,但是当MQTT类型为PUBLISH(0011)时 低4位开始有意义,具体如下:</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1fdb1211e214cb9c03493c1e267db436?method=download&shareKey=55700ec7529325c88727738673944231" alt="geshi"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当byte1的高4位取值为0011时，byte1的低4位就会有意义</span><br><span class="line"></span><br><span class="line">DUP位: 如果设置0客户端或服务端第一次请求发送这个PUBLISH报文,如果设置1，表示这可能是一个早前报文请求的重发</span><br><span class="line">Qos位: 由2位组成取值范围是0-3(00~11) 服务质量,每一个值代表的意义如下</span><br><span class="line"></span><br><span class="line">Qos值    bit2    bit1      描述</span><br><span class="line"> 0        0       0     消息可能丢失</span><br><span class="line"> 1        0       1     消息不会丢失,但是可能重复</span><br><span class="line"> 2        1       0     消息不会丢失,也不会重复</span><br><span class="line"> x        1       1     保留位</span><br><span class="line"> </span><br><span class="line">RETAIN位: 1/0</span><br><span class="line">	1. 如果设置1 那么服务器端必须保存Qos信息,以便将Qos信息传递给其它的订阅者；</span><br><span class="line">	2. 如果服务器端收到一个RETAIN为1并且QoS0的消息，服务器端需要丢弃掉原来那个主题保留任何消息，将这个新的QoS0消息当作主题的新保留消息 </span><br><span class="line">	3. 服务端发送消息给订阅者,如果订阅者是一个新的，那么RETAIN为1，如果订阅者是一个已经存在的RETAIN为0</span><br><span class="line">	4. RETAIN为0并且有效载荷为0的报文，服务端会当作正常消息处理</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="5-3-可变报头"><a href="#5-3-可变报头" class="headerlink" title="5.3 可变报头"></a>5.3 可变报头</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可变报头包含主题名和报文标识符</span><br></pre></td></tr></table></figure>

<h4 id="5-4-有效载荷"><a href="#5-4-有效载荷" class="headerlink" title="5.4 有效载荷"></a>5.4 有效载荷</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主要是传递的消息</span><br></pre></td></tr></table></figure>

<h3 id="第6节-MQTT协议的工作原理"><a href="#第6节-MQTT协议的工作原理" class="headerlink" title="第6节 MQTT协议的工作原理"></a>第6节 MQTT协议的工作原理</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9bee4853a8bd940dbc1927ddfc1ba49c?method=download&shareKey=f7c7d216b16a34aa5c478606e1c1aed5" alt="mqtt"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MQTT协议基于TCP/IP协议,TCP/IP协议是一个安全稳定的协议,通信需要服务端和客户端经历三次握手四次挥手，建立一个稳定的通道然后在进行数据传输。MQTT协议建立在TCP/IP协议之上,也是需要编写服务端(上图中的Broker)和客户端(消息发布者和消息订阅者).</span><br><span class="line"></span><br><span class="line">下面就用案例进行MQTT学习</span><br></pre></td></tr></table></figure>

<h2 id="第二章-MQTT代理服务器介绍和搭建"><a href="#第二章-MQTT代理服务器介绍和搭建" class="headerlink" title="第二章 MQTT代理服务器介绍和搭建"></a>第二章 MQTT代理服务器介绍和搭建</h2><h3 id="第1节-MQTT代理服务器介绍"><a href="#第1节-MQTT代理服务器介绍" class="headerlink" title="第1节 MQTT代理服务器介绍"></a>第1节 MQTT代理服务器介绍</h3><h4 id="1-1-Eclipse-Mosquitto"><a href="#1-1-Eclipse-Mosquitto" class="headerlink" title="1.1 Eclipse Mosquitto"></a>1.1 Eclipse Mosquitto</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网地址: https://mosquitto.org/</span><br><span class="line"></span><br><span class="line">介绍:</span><br><span class="line">1. 开源的消息代理服务器</span><br><span class="line">2. 支持MQTT协议版本 3.1 3.1.1 5.0 版本</span><br><span class="line">3. 轻量级,适用从低功耗单板计算机到完整服务器的所有设备</span><br><span class="line">4. 不支持集群功能</span><br></pre></td></tr></table></figure>

<h4 id="1-2-EMQX"><a href="#1-2-EMQX" class="headerlink" title="1.2 EMQX"></a>1.2 EMQX</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网地址: https://www.emqx.io/zh</span><br><span class="line"></span><br><span class="line">介绍:</span><br><span class="line">1. 开源大规模分布式MQTT代理服务器</span><br><span class="line">2. 支持MQTT协议版本 3.1 3.1.1 5.0 版本</span><br><span class="line">3. 单台并发连接数可以高达一亿,每秒处理百万级消息</span><br><span class="line">4. 安全可靠的消息传递</span><br></pre></td></tr></table></figure>

<h3 id="第2节-MQTT代理服务器安装-EMQX"><a href="#第2节-MQTT代理服务器安装-EMQX" class="headerlink" title="第2节 MQTT代理服务器安装(EMQX)"></a>第2节 MQTT代理服务器安装(EMQX)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EMQX安装: windows</span><br><span class="line">1. 下载地址: https://www.emqx.io/zh/get-started</span><br><span class="line">2. 安装步骤:</span><br><span class="line">	第一步: 下载 emqx-5.3.2-windows-amd64.zip 安装包,版本可能和我这个不同</span><br><span class="line">	第二步: 解压</span><br><span class="line">	第三步: 打开命令行(以管理员身份运行),切换到解压目录的bin目录下</span><br><span class="line">	第四步: 安装,在bin目录下执行EMQX安装命令  emqx.cmd install ,完成之后有类似下面的输出,说明安装成功,只需要安装一次</span><br><span class="line">        D:\app\emqx-5.3.2-windows-amd64\bin&gt;emqx.cmd install</span><br><span class="line">        EMQX_NODE__DB_ROLE [node.role]: core</span><br><span class="line">        EMQX_NODE__DB_BACKEND [node.db_backend]: mnesia</span><br><span class="line">        D:\app\emqx-5.3.2-windows-amd64\erts-13.2.2.4\bin\erlsrv.exe: Service emqx_5.3.2 added to system.</span><br><span class="line">        [SC] ChangeServiceConfig 成功</span><br><span class="line">	第五步(可选择): 如果想将EMQX从windows上卸载可以执行 emqx.cmd uninstall 命令</span><br><span class="line">	第六步: 去windows服务列表中找到第四步安装的EMQX的服务,鼠标右键启动</span><br><span class="line">	第七步: 在命令行输入 emqx.cmd console 命令，查看是否启动成功,如果有类似以下日志启动成功</span><br><span class="line">		D:\app\emqx-5.3.2-windows-amd64\bin&gt;emqx.cmd console</span><br><span class="line">        EMQX_LOG__CONSOLE_HANDLER__ENABLE [log.console.enable]: true</span><br><span class="line">        EMQX_NODE__DB_ROLE [node.role]: core</span><br><span class="line">        EMQX_NODE__DB_BACKEND [node.db_backend]: mnesia</span><br><span class="line"></span><br><span class="line">        D:\app\emqx-5.3.2-windows-amd64&gt;D:\app\emqx-5.3.2-windows-amd64\erts-13.2.2.4\bin\erl.exe -mode embedded -boot &quot;D:\app\emqx-5.3.2-windows-amd64\releases\5.3.2\start&quot; -config &quot;D:\app\emqx-5.3.2-windows-amd64\data\configs\app.2024.05.06.16.38.19.config&quot; -args_file &quot;D:\app\emqx-5.3.2-windows-amd64\data\configs\vm.2024.05.06.16.38.19.args&quot; -mnesia dir &#x27;d:/app/emqx-5.3.2-windows-amd64/data/mnesia/emqx@127.0.0.1&#x27;</span><br><span class="line">        Listener ssl:default on 0.0.0.0:8883 started.</span><br><span class="line">        Listener tcp:default on 0.0.0.0:1883 started.</span><br><span class="line">        Listener ws:default on 0.0.0.0:8083 started.</span><br><span class="line">        Listener wss:default on 0.0.0.0:8084 started.</span><br><span class="line">        Listener http:dashboard on :18083 started.</span><br><span class="line">        EMQX 5.3.2 is running now!</span><br><span class="line">        Eshell V13.2.2.4  (abort with ^G)</span><br><span class="line">        v5.3.2(emqx@127.0.0.1)1&gt;</span><br><span class="line">    </span><br><span class="line">    第八步:通过浏览器访问控制台http://127.0.0.1:18083 默认初始化用户名: admin 默认密码: public 进入之后会让你重新修改密码</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">注意事项: (第六步+第七步)这种启动方式在开发时使用,如果想正式环境使用请遵循官网命令启动介绍: 正式环境启动在bin目录下直接输入 emqx start进行EMQX启动,这时不需要（第六步和第七步）</span><br><span class="line"></span><br><span class="line">官网命令详细使用地址: https://www.emqx.io/docs/zh/latest/admin/cli.html    </span><br></pre></td></tr></table></figure>

<h3 id="第3节-MQTT客户端工具介绍"><a href="#第3节-MQTT客户端工具介绍" class="headerlink" title="第3节 MQTT客户端工具介绍"></a>第3节 MQTT客户端工具介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EMQX官网自带工具MQTTX官网地址: https://mqttx.app/zh/downloads</span><br></pre></td></tr></table></figure>

<h3 id="第4节-MQTT客户端工具安装和使用"><a href="#第4节-MQTT客户端工具安装和使用" class="headerlink" title="第4节 MQTT客户端工具安装和使用"></a>第4节 MQTT客户端工具安装和使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">傻瓜式安装,无脑下一步</span><br></pre></td></tr></table></figure>

<h2 id="第三章MQTT协议练习-Java版"><a href="#第三章MQTT协议练习-Java版" class="headerlink" title="第三章MQTT协议练习(Java版)"></a>第三章MQTT协议练习(Java版)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先在编写代码前需要安装Broker,如果已经安装完,需要将Broker启动起来,我这里使用EMQX作为Broker. 接下来开始代码编写.</span><br><span class="line"></span><br><span class="line">基于maven项目,需要向项目中添加maven依赖,依赖来自于EMQX官网地址为: https://www.emqx.com/zh/mqtt-client-sdk</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.eclipse.paho&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;org.eclipse.paho.client.mqttv3&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">依赖添加完成之后,需要编写 客户端-消息订阅者和 客户端-消息发布者</span><br></pre></td></tr></table></figure>

<h3 id="第1节-MQTT客户端之消息订阅者"><a href="#第1节-MQTT客户端之消息订阅者" class="headerlink" title="第1节 MQTT客户端之消息订阅者"></a>第1节 MQTT客户端之消息订阅者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.*;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息订阅者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subscribe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理服务器地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER=<span class="string">&quot;tcp://127.0.0.1:1883&quot;</span>;</span><br><span class="line">    <span class="comment">//客户端ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLIENT_ID=<span class="string">&quot;test01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MqttException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建消息发布客户端对象</span></span><br><span class="line"><span class="comment">            第一个参数: 代理服务器地址</span></span><br><span class="line"><span class="comment">            第二个参数: 给客户端起一个唯一名字</span></span><br><span class="line"><span class="comment">            第三个参数: 使用MemoryPersistence进行动态消息存储,如果不给值,使用内部默认的类进行持久消息存储</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">MqttClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqttClient</span>(BROKER, CLIENT_ID, <span class="keyword">new</span> <span class="title class_">MemoryPersistence</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建MQTT连接配置</span></span><br><span class="line">        <span class="type">MqttConnectOptions</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqttConnectOptions</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            是否清空会话session</span></span><br><span class="line"><span class="comment">            如果设置false那么就会保留历史session</span></span><br><span class="line"><span class="comment">            如果设置成true每次连接都是新的session</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        connection.setCleanSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将客户端和连接关联</span></span><br><span class="line">        client.connect(connection);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置回调函数(当发布者发布消息后被订阅者监听到,并且通过回调函数进行接收)</span></span><br><span class="line">        client.setCallback(<span class="keyword">new</span> <span class="title class_">MqttCallback</span>() &#123;</span><br><span class="line">            <span class="comment">//连接丢失</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectionLost</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接已丢失...&quot;</span>+throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息已送达</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">messageArrived</span><span class="params">(String s, MqttMessage mqttMessage)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息已送达...订阅的主题:&quot;</span>+s+<span class="string">&quot; 收到的消息为:\n&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(mqttMessage.getPayload()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息接收完成</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deliveryComplete</span><span class="params">(IMqttDeliveryToken iMqttDeliveryToken)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息接受已完成....&quot;</span>+iMqttDeliveryToken.isComplete());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 订阅test主题的消息</span></span><br><span class="line"><span class="comment">         * subscribe消息订阅函数</span></span><br><span class="line"><span class="comment">         * 参数1: 要订阅的主题</span></span><br><span class="line"><span class="comment">         * 参数2: 服务质量,取值为 0、1、2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        client.subscribe(<span class="string">&quot;test&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息监听开始.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第2节-MQTT客户端之消息发布者"><a href="#第2节-MQTT客户端之消息发布者" class="headerlink" title="第2节 MQTT客户端之消息发布者"></a>第2节 MQTT客户端之消息发布者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttClient;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttConnectOptions;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttException;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttMessage;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发布者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Publish</span> &#123;</span><br><span class="line">    <span class="comment">//代理服务器地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER=<span class="string">&quot;tcp://127.0.0.1:1883&quot;</span>;</span><br><span class="line">    <span class="comment">//客户端ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLIENT_ID=<span class="string">&quot;test02&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MqttException, UnsupportedEncodingException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建消息发布客户端对象</span></span><br><span class="line"><span class="comment">            第一个参数: 代理服务器地址</span></span><br><span class="line"><span class="comment">            第二个参数: 给客户端起一个唯一名字</span></span><br><span class="line"><span class="comment">            第三个参数: 使用MemoryPersistence进行动态消息存储,如果不给值,使用内部默认的类进行持久消息存储</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">MqttClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqttClient</span>(BROKER, CLIENT_ID, <span class="keyword">new</span> <span class="title class_">MemoryPersistence</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建MQTT连接配置</span></span><br><span class="line">        <span class="type">MqttConnectOptions</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqttConnectOptions</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            是否清空会话session</span></span><br><span class="line"><span class="comment">            如果设置false那么就会保留历史session</span></span><br><span class="line"><span class="comment">            如果设置成true每次连接都是新的session</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        connection.setCleanSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//将客户端和连接关联</span></span><br><span class="line">        client.connect(connection);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建消息</span></span><br><span class="line"><span class="comment">            调用有参构造函数进行创建,参数传一个byte数组,数组中是要发布的消息(有效载荷)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">MqttMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqttMessage</span>(<span class="string">&quot;我是要发布的消息&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//设置服务质量</span></span><br><span class="line">        message.setQos(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            消息发布</span></span><br><span class="line"><span class="comment">            第一个参数: 消息发送到哪一个主题</span></span><br><span class="line"><span class="comment">            第二个参数: 发送的消息对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        client.publish(<span class="string">&quot;test&quot;</span>,message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断开连接</span></span><br><span class="line">        client.disconnect();</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
        <tag>tcp</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>快速入门RabbitMQ</title>
    <url>/2024/05/13/RabbitMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者: 夜泊1990</span><br><span class="line">企鹅: 1611756908</span><br><span class="line">鹅群: 948233848</span><br><span class="line">邮箱: hd1611756908@163.com</span><br><span class="line">博客: https://hd1611756908.github.io/</span><br><span class="line">B 站: https://space.bilibili.com/514155929/</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第一章-RabbitMQ介绍"><a href="#第一章-RabbitMQ介绍" class="headerlink" title="第一章 RabbitMQ介绍"></a>第一章 RabbitMQ介绍</h2><h3 id="第1节-MQ是什么"><a href="#第1节-MQ是什么" class="headerlink" title="第1节 MQ是什么"></a>第1节 MQ是什么</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 消息队列(Message Queue),又叫做消息中间件</span><br><span class="line">2. 用高效可靠的消息传递机制进行与平台无关的数据交流,并基于数据通信来进行分布式系统的集成</span><br><span class="line">3. 通过提供消息传递和消息队列模型,可以在分布式环境下扩展进程的通信</span><br><span class="line">4. MQ 是用来解决通信的问题,主要用来帮我们存储和转发消息</span><br></pre></td></tr></table></figure>
<hr>
<span id="more"></span>

<h3 id="第2节-MQ-的主要特点"><a href="#第2节-MQ-的主要特点" class="headerlink" title="第2节 MQ 的主要特点"></a>第2节 MQ 的主要特点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 是一个独立运行的服务.生产者发送消息,消费者接收消费,需要先跟服务器建立连接</span><br><span class="line">2. 采用队列作为数据结构,有先进先出的特点</span><br><span class="line">3. 具有发布/订阅的模型,消费者可以获取自己需要的消息</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第3节-RabbitMQ介绍"><a href="#第3节-RabbitMQ介绍" class="headerlink" title="第3节 RabbitMQ介绍"></a>第3节 RabbitMQ介绍</h3><ul>
<li>官网地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.rabbitmq.com/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网介绍: RabbitMQ is the most widely deployed open source message broker</span><br><span class="line">中文解释: RabbitMQ 是部署最广泛的开源消息队列代理服务器</span><br><span class="line"></span><br><span class="line">RabbitMQ是一个开源的AMQP(高级消息队列协议)实现,服务器端用Erlang语言编写,支持多种客户端,如:Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第二章-RabbitMQ安装-Docker"><a href="#第二章-RabbitMQ安装-Docker" class="headerlink" title="第二章 RabbitMQ安装(Docker)"></a>第二章 RabbitMQ安装(Docker)</h2><h3 id="第1节-安装步骤"><a href="#第1节-安装步骤" class="headerlink" title="第1节 安装步骤"></a>第1节 安装步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 首先就是查询镜像,我们要用带有management版本的，此版本是带有管理界面的</span><br><span class="line">    </span><br><span class="line">    docker search rabbitmq:management</span><br><span class="line"></span><br><span class="line">2. 拉取镜像</span><br><span class="line"></span><br><span class="line">    docker pull rabbitmq:management</span><br><span class="line"></span><br><span class="line">3. 查看已下载的rabbitmq镜像</span><br><span class="line"></span><br><span class="line">    docker images</span><br><span class="line"></span><br><span class="line">4. 运行RabbitMQ服务器</span><br><span class="line"></span><br><span class="line">    docker run --name rabbitmq-server -d -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br><span class="line">    </span><br><span class="line">    4.1 –name指定了容器名称</span><br><span class="line">    4.2 -d 指定容器以后台守护进程方式运行</span><br><span class="line">    4.3 -p指定容器内部端口号与宿主机之间的映射，rabbitmq默认要使用15672为其web端界面访问时端口，5672为数据通信端口</span><br><span class="line"></span><br><span class="line">5. 执行docker ps 命令查看当前运行服务器列表</span><br><span class="line"></span><br><span class="line">6. 查看启动的RabbitMQ服务器日志命令</span><br><span class="line">    </span><br><span class="line">    docker logs -f 容器ID</span><br><span class="line">    </span><br><span class="line">    从打印的日志中可以发现这几句日志信息</span><br><span class="line">    Creating user ‘guest’ // 默认创建了用户名 guest</span><br><span class="line">    Setting user tags for user ‘guest’ to [administrator] // 添加了administrator角色</span><br><span class="line">    Setting permissions for ‘guest’ in ‘/‘ to ‘.‘, ‘.‘, ‘.*’ // 密码为 guest</span><br><span class="line"></span><br><span class="line">7. 访问RabbitMQ的web管理页面</span><br><span class="line"></span><br><span class="line">    在浏览器中输入: http://192.168.1.129:15672</span><br><span class="line">    </span><br><span class="line">    192.168.1.129是我的主机IP,换成个人的IP地址即可</span><br><span class="line">    输入默认创建的用户名和密码 guest guest</span><br></pre></td></tr></table></figure>

<img src="https://note.youdao.com/yws/api/personal/file/D076E449167648528F050D3073B89206?method=download&shareKey=024152ae70e2306af337b15040844d3b" alt="RabbitMQ-success" style="zoom:80%;" />

<hr>
<h3 id="第2节-用户管理"><a href="#第2节-用户管理" class="headerlink" title="第2节 用户管理"></a>第2节 用户管理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给RabbitMQ服务器添加新用户并且赋予权限</span><br><span class="line">    </span><br><span class="line">    1. 进入容器</span><br><span class="line">        docker exec -i -t 0e7e57214cfb bin/bash 通过容器ID进入容器内部</span><br><span class="line">        </span><br><span class="line">    2. 添加用户名和密码都是root的用户</span><br><span class="line">        rabbitmqctl add_user root root</span><br><span class="line">    </span><br><span class="line">    3. 赋予root用户所有权限</span><br><span class="line">        rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">    </span><br><span class="line">    4. 赋予root用户administrator角色</span><br><span class="line">        rabbitmqctl set_user_tags root administrator</span><br><span class="line">    </span><br><span class="line">    5. 查看所有用户列表,即可看到我们添加的root</span><br><span class="line">        rabbitmqctl list_users</span><br><span class="line">    </span><br><span class="line">    6. 回到我们的web管理页面,将原有的用户注销,使用新创建的root用户登录测试</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第三章-RabbitMQ架构及通讯范式"><a href="#第三章-RabbitMQ架构及通讯范式" class="headerlink" title="第三章 RabbitMQ架构及通讯范式"></a>第三章 RabbitMQ架构及通讯范式</h2><h3 id="第1节-RabbitMQ的整体架构图"><a href="#第1节-RabbitMQ的整体架构图" class="headerlink" title="第1节 RabbitMQ的整体架构图"></a>第1节 RabbitMQ的整体架构图</h3><table>
<thead>
<tr>
<th align="center">架构</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://note.youdao.com/yws/api/personal/file/8863E25C1B284CC1A8970B4B57E836E6?method=download&shareKey=e86315ae9c7142836439b405eeb18ba7" alt="RabbitMQ" style="zoom:80%;" /></td>
</tr>
</tbody></table>
<hr>
<ul>
<li>Producer</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息发布者,主要用来进行消息发布</span><br></pre></td></tr></table></figure>

<ul>
<li>Exchange</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">交换器,消息发布者将消息发送给交换器,交换器在通过路由发送到队列中</span><br></pre></td></tr></table></figure>

<ul>
<li>Queue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保存消息</span><br></pre></td></tr></table></figure>

<ul>
<li>Customer</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息消费者</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个消息(message)从开始到结束的过程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息(message)被发布者(Producer)发送给交换器(exchange)然后交换机将收到的消息根据路由规则分发给绑定的队列(queue)最后将消息投递给订阅了此队列的消费者(consumer),或者消费者按照需求自行获取</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第四章-快速入门-RabbitMQ-HelloWorld"><a href="#第四章-快速入门-RabbitMQ-HelloWorld" class="headerlink" title="第四章 快速入门(RabbitMQ-HelloWorld)"></a>第四章 快速入门(RabbitMQ-HelloWorld)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RabbitMQ快速入门,使用Java语言来向RabbitMQ服务器发送和消费消息</span><br></pre></td></tr></table></figure>
<h3 id="第1节-原理图"><a href="#第1节-原理图" class="headerlink" title="第1节 原理图"></a>第1节 原理图</h3><table>
<thead>
<tr>
<th align="center">HelloWorld</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://note.youdao.com/yws/api/personal/file/73FEFD26A1A9415DAFA7FAA35666DB2E?method=download&shareKey=a214ae16b858ce24c5bc0bf89125cff0" alt="python-one"></td>
</tr>
</tbody></table>
<ul>
<li>P: producer  生产者</li>
<li>C: consumer  消费者</li>
<li>中间红色的部分是一个队列,在RabbitMQ中代表消息缓冲区</li>
</ul>
<hr>
<h3 id="第2节-客户端依赖"><a href="#第2节-客户端依赖" class="headerlink" title="第2节 客户端依赖"></a>第2节 客户端依赖</h3><blockquote>
<p>在编写Java代码之前首先需要创建Java项目并且添加maven依赖,使用的是5.8.0版本的MQ客户端</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">依赖添加完成之后就是编写代码</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第3节-消息发布"><a href="#第3节-消息发布" class="headerlink" title="第3节 消息发布"></a>第3节 消息发布</h3><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向队列中发送一个消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerMessage</span> &#123;</span><br><span class="line">    <span class="comment">//声明一个队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//构建一个消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitMQ&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            向队列中发送上面的message消息</span></span><br><span class="line"><span class="comment">            里面涉及到两个参数</span></span><br><span class="line"><span class="comment">            第2个参数  routingKey : 指定发送队列的名称</span></span><br><span class="line"><span class="comment">            第4个参数  body       : 设置需要发送的消息,byte数组格式</span></span><br><span class="line"><span class="comment">            其它参数会在后面介绍其它功能时详解</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制台查看</li>
</ul>
<table>
<thead>
<tr>
<th align="center">管理页面</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://note.youdao.com/yws/api/personal/file/857866450CCF4C4EB915A1D2520023FF?method=download&shareKey=ab85826f124ccb750b8a0a49ee90389e" alt="RabbitMQ-info1"  /></td>
</tr>
<tr>
<td align="center"><img src="https://note.youdao.com/yws/api/personal/file/8112AB223BD9422EBC756A94F0A84D56?method=download&shareKey=9c582e5c4c58c616463ec1b95cb15107" alt="RabbitMQ-info2"></td>
</tr>
</tbody></table>
<hr>
<h3 id="第4节-消息消费"><a href="#第4节-消息消费" class="headerlink" title="第4节 消息消费"></a>第4节 消息消费</h3><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中获取消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerMessage</span> &#123;</span><br><span class="line">    <span class="comment">//声明要获取消息的队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            消费队列里面的消息</span></span><br><span class="line"><span class="comment">            参数介绍: 暂时只关注第1、3、4这三个参数,第二个参数在下面的案例中会介绍到</span></span><br><span class="line"><span class="comment">            第1个参数: 设置待消费的队列名称</span></span><br><span class="line"><span class="comment">            第3个参数: 当消息被传递过来时，回调</span></span><br><span class="line"><span class="comment">            第4个参数: 当消费者被意外取消或关闭时回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制台查看</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当消费完成在回到RabbitMQ的web管理页面查看消息,会发队列中的消息已经被消费</span><br></pre></td></tr></table></figure>
<ul>
<li>注意<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在启动代码的时候先启动消费者,后启动提供者,先启动消费者创建队列,后启动发布者向队列中发布数据</span><br><span class="line">当前入门的例子,因为手动创建了具体的队列所以不会出现发送消息到指定队列不存在的问题,但是接下来后面的练习可能会出错.</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第五章-工作队列-RabbitMQ-Work"><a href="#第五章-工作队列-RabbitMQ-Work" class="headerlink" title="第五章 工作队列(RabbitMQ-Work)"></a>第五章 工作队列(RabbitMQ-Work)</h2><h3 id="第1节-原理图-1"><a href="#第1节-原理图-1" class="headerlink" title="第1节 原理图"></a>第1节 原理图</h3><p><img src="https://note.youdao.com/yws/api/personal/file/4206F7B415534996A787434BF870F1BF?method=download&shareKey=cde013258e1b91a4d13683ffe7285112" alt="python-two"></p>
<hr>
<h3 id="第2节-Work-工作队列-介绍"><a href="#第2节-Work-工作队列-介绍" class="headerlink" title="第2节 Work(工作队列)介绍"></a>第2节 Work(工作队列)介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HelloWorld入门的例子介绍了我们提供者向队列中发送一个消息,消费者从队列中取出消息消费;接下来我们将要创建一个工作队列,用来在多个消费者(consumer)之间分发任务,然后观察,我们分发的任务在多个工作者之间是怎么进行消费的</span><br></pre></td></tr></table></figure>
<ul>
<li>工作队列(任务队列)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如消息提供者将消息发送到任务队列中,根据上面图示,任务队列会被多个消费者(consumer)连接,这时候如果我们向任务队列中发送多个任务,这些任务会被所有的消费者(consumer)共享,那么问题来了,这个任务队列是怎么将任务合理的分配给消费者(consumer)进行消费的.</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第3节-Work-工作队列-实现"><a href="#第3节-Work-工作队列-实现" class="headerlink" title="第3节 Work(工作队列)实现"></a>第3节 Work(工作队列)实现</h3><ul>
<li>需求举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息发布者: 向队列中发送多条消息(比如我这里发送10条消息)</span><br><span class="line">消息消费者: 创建多个消费者验证,查看每个消费者处理的消息任务数(我这里创建两个消费者)</span><br></pre></td></tr></table></figure>

<ul>
<li>消息发布代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向工作队列中发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerWorkMessage</span> &#123;</span><br><span class="line">    <span class="comment">//声明一个队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//构建10条消息并且发送到队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitMQ i=&quot;</span>+i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息消费代码(下面是两个消费者)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中获取消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerWorkMessage1</span> &#123;</span><br><span class="line">    <span class="comment">//声明要获取消息的队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            消费队列里面的消息</span></span><br><span class="line"><span class="comment">            参数介绍: 暂时只关注第1、3、4这三个参数,第二个参数在下面的案例中会介绍到</span></span><br><span class="line"><span class="comment">            第1个参数: 设置待消费的队列名称</span></span><br><span class="line"><span class="comment">            第3个参数: 当消息被传递过来时，回调</span></span><br><span class="line"><span class="comment">            第4个参数: 当消费者被意外取消或关闭时回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中获取消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerWorkMessage2</span> &#123;</span><br><span class="line">    <span class="comment">//声明要获取消息的队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            消费队列里面的消息</span></span><br><span class="line"><span class="comment">            参数介绍: 暂时只关注第1、3、4这三个参数,第二个参数在下面的案例中会介绍到</span></span><br><span class="line"><span class="comment">            第1个参数: 设置待消费的队列名称</span></span><br><span class="line"><span class="comment">            第3个参数: 当消息被传递过来时，回调</span></span><br><span class="line"><span class="comment">            第4个参数: 当消费者被意外取消或关闭时回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果展示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面代码所得的结果显示: </span><br><span class="line"></span><br><span class="line">消息发布者发送的10条消息:</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=0&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=1&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=2&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=3&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=4&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=5&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=6&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=7&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=8&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=9&#x27;</span><br><span class="line"></span><br><span class="line">消费者1消费的消息: 1,3,5,7,9</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=1&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=3&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=5&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=7&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=9&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消费者2消费的消息: 0,2,4,6,8</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=0&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=2&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=4&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=6&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=8&#x27; </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>结果分析<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 通过上面的结果可以看出发布者发布消息会平均分配给每一个消费者,采用默认的任务分发机制(轮询)</span><br><span class="line">2. 这种方式有优点当然也有缺点</span><br><span class="line">    2.1 优点: 可以轻易的并行工作,如果我们积压很多任务，我们可以通过增加工作者(consumer)来解决这一问题,使得系统的伸缩性更强</span><br><span class="line">    2.2 缺点: 这种分发机制没有考虑处理处理任务的时间问题(因为他分配任务的时候是一次性分配,并非是一个一个分配),按照轮询的方式将任务等分给了两个消费者,可能某一个消费者性能比较差,累积任务会越来越多,所以一直忙个不停;而另一个消费者性能比较好,处理任务块,可能闲的不行,这就造成了资源浪费</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    怎么解决这个问题呢? ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 向下看 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第4节-Fair-dispatch-公平分发"><a href="#第4节-Fair-dispatch-公平分发" class="headerlink" title="第4节 Fair dispatch(公平分发)"></a>第4节 Fair dispatch(公平分发)</h3><h4 id="4-1-原理图"><a href="#4-1-原理图" class="headerlink" title="4.1 原理图"></a>4.1 原理图</h4><table>
<thead>
<tr>
<th align="center">公平分发</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://note.youdao.com/yws/api/personal/file/BF2A1C28FB224A9CB377B696083EBD23?method=download&shareKey=6faeae09766496483f4324d86177b69b" alt="python-eight"></td>
</tr>
</tbody></table>
<hr>
<h4 id="4-2-公平分发原则"><a href="#4-2-公平分发原则" class="headerlink" title="4.2 公平分发原则"></a>4.2 公平分发原则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面的轮询机制会造成资源浪费的问题,原因是因为RabbitMQ在分发任务的时候盲目的一次性平均分配任务,它不看消费者是否应答(分发给消费者的任务后,不看消费者是否完成,直接在分配，这样就造成了累积),为了解决这个问题,RabbitMQ提供了一个方法来解决</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int prefetchCount = 1;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br><span class="line"></span><br><span class="line">这段代码的意义就是来限制RabbitMQ只发不超过1条的消息给同一个消费者,且当消息处理完毕后,有了反馈,才会进行第二次发送.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当然在使用basicQos方法的时候还需要设置两个参数</span><br><span class="line">1、设置autoAck为false channel.basicConsume(QUEUE_NAME,false,deliverCallback,consumerTag -&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">2、在从MQ获取到消息之后设置 channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line"></span><br><span class="line">这两个参数的意义: </span><br><span class="line">    autoAck: 设置应答模式,默认是自动应答</span><br><span class="line">        - 自动应答:只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费</span><br><span class="line">        - 手动应答:消费者从队列中获取消息后,服务器会将该消息标记为不可用状态，等待消费者的反馈,如果消费者一直没有反馈,那么该消息将一直处于不可用状态,打开手动确认还有一个好处就是当消费者不正常死亡(通道关闭,连接关闭或TCP连接丢失),RabbitMQ会将这个消息进行重新加入队列进行排队.当然如果正常消费,RabbitMQ就会正常删除掉他.</span><br><span class="line">        - 当使用公平分发的时候,必须取消自动应答模式,改为手动应答模式.</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><ul>
<li>消息发布代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向任务队列中发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerWorkMessage</span> &#123;</span><br><span class="line">    <span class="comment">//声明一个队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//限制发送消息给同一个消费者不得超过一条</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建10条消息并且发送到队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitMQ i=&quot;</span>+i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息消费代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费者1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中获取消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerWorkMessage1</span> &#123;</span><br><span class="line">    <span class="comment">//声明要获取消息的队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//保证发送给消费者的消息只分发一次</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            <span class="comment">//开启手动消息应答</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            消费队列里面的消息</span></span><br><span class="line"><span class="comment">            参数介绍: 这里只说第2个参数，其他参数前面已经说过</span></span><br><span class="line"><span class="comment">            第2个参数 autoAck : false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">false</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中获取消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerWorkMessage2</span> &#123;</span><br><span class="line">    <span class="comment">//声明要获取消息的队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//保证发送给消费者的消息只分发一次</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            <span class="comment">//给一个消费者开启一点延时,模拟性能问题</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开启手动消息应答</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            消费队列里面的消息</span></span><br><span class="line"><span class="comment">            参数介绍: 这里只说第2个参数，其他参数前面已经说过</span></span><br><span class="line"><span class="comment">            第2个参数 autoAck : false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">false</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果展示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行上面的代码打印出来的消息为:</span><br><span class="line"></span><br><span class="line">消息提供者:发送10条消息</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=0&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=1&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=2&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=3&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=4&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=5&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=6&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=7&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=8&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=9&#x27;</span><br><span class="line"></span><br><span class="line">消息消费者1:(消费者1具体处理几条不一定)</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=1&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=2&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=4&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=5&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=6&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=8&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=9&#x27;</span><br><span class="line"></span><br><span class="line">消息消费者2:(消费者2具体处理几条不一定)</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=0&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=3&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=7&#x27;</span><br><span class="line"></span><br><span class="line">通过以上代码运行可以看出不在是基本的轮询，而是采用了公平分发的原则。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第5节-消息队列的持久化"><a href="#第5节-消息队列的持久化" class="headerlink" title="第5节 消息队列的持久化"></a>第5节 消息队列的持久化</h3><h4 id="5-1-消息持久化介绍"><a href="#5-1-消息持久化介绍" class="headerlink" title="5.1 消息持久化介绍"></a>5.1 消息持久化介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面介绍的队列都是在RabbitMQ退出或者崩溃时就会消失的队列,如果当时队列里面还有消息未被消费,那么异常退出会造成任务丢失,怎么保证就算RabbitMQ意外退出,也不会造成队列中的任务丢失呢,这回就用到了消息队列的持久化.</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="5-2-消息持久化设置"><a href="#5-2-消息持久化设置" class="headerlink" title="5.2 消息持久化设置"></a>5.2 消息持久化设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置持久化队列比较简单只需要在提供者和消费者都设置</span><br><span class="line">//第二个参数设置为true</span><br><span class="line">channel.queueDeclare(QUEUE_NAME,true,false,false,null);</span><br><span class="line"></span><br><span class="line">这样当我们消息发布者发布一条消息之后然后重启docker RabbitMQ服务器,查看web管理页面会发现,消息还在</span><br><span class="line"></span><br><span class="line">重启docker容器的命令: docker container restart bf44c7a5089a</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="5-3-消息持久化实现"><a href="#5-3-消息持久化实现" class="headerlink" title="5.3 消息持久化实现"></a>5.3 消息持久化实现</h4><ul>
<li>消息发送代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向队列中发送一个消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerMessage</span> &#123;</span><br><span class="line">    <span class="comment">//声明一个队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            声明一个持久化队列</span></span><br><span class="line"><span class="comment">            参数说明:第2个参数: durable: 设置为true,这时我们声明的队列就是一个持久化队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//构建一个消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitMQ&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息消费代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中获取消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerMessage</span> &#123;</span><br><span class="line">    <span class="comment">//声明要获取消息的队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明一个队列,第2个参数,设置为true声明一个持久化队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第六章-发布-x2F-订阅-RabbitMQ-Publish-amp-Subscribe"><a href="#第六章-发布-x2F-订阅-RabbitMQ-Publish-amp-Subscribe" class="headerlink" title="第六章 发布&#x2F;订阅(RabbitMQ-Publish&amp;Subscribe)"></a>第六章 发布&#x2F;订阅(RabbitMQ-Publish&amp;Subscribe)</h2><h3 id="第1节-Publish-amp-Subscribe原理图"><a href="#第1节-Publish-amp-Subscribe原理图" class="headerlink" title="第1节 Publish&amp;Subscribe原理图"></a>第1节 Publish&amp;Subscribe原理图</h3><table>
<thead>
<tr>
<th align="center">Publish&amp;Subscribe</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://note.youdao.com/yws/api/personal/file/F597EF30C192405787080AB890611CA0?method=download&shareKey=be3b46c9d51c7386649f03285c0422fc" alt="python-four"></td>
</tr>
</tbody></table>
<hr>
<h3 id="第2节-Publish-amp-Subscribe介绍"><a href="#第2节-Publish-amp-Subscribe介绍" class="headerlink" title="第2节 Publish&amp;Subscribe介绍"></a>第2节 Publish&amp;Subscribe介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在前面的例子中,我们创建了一个工作队列,都是一个任务只交给一个消费者.这次我们做一些完全不同的事儿.将消息发送给多个消费者,这种模式叫做 &quot;发布/订阅&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第3节-Exchanges-交换器"><a href="#第3节-Exchanges-交换器" class="headerlink" title="第3节 Exchanges(交换器)"></a>第3节 Exchanges(交换器)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要想实现上面的发布/订阅这种模式,需要使用到交换器</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-1-交换器是干什么的"><a href="#3-1-交换器是干什么的" class="headerlink" title="3.1 交换器是干什么的"></a>3.1 交换器是干什么的</h4><blockquote>
<p>前面的例子,我们都是基于一个队列发送和接收消息.现在介绍一下完整的消息传递模式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RabbitMQ消息模式的核心理念:</span><br><span class="line">1. 生产者没有直接发送任何消费到队列</span><br><span class="line">2. 实际上,生产者都不知道这个消费是发送给哪个队列的</span><br><span class="line">3. 相反,生产者只需发送消息给交换器,交换器一方面它接受生产者的消息,另一方面向队列推送消息</span><br><span class="line">4. 交换器必须清楚的知道如何处理接收到的消息,指定一个队列或者指定多个队列或者是直接丢弃消息等处理方式,这些规则通过交换器的类型进行定义</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-交换器的常见类型"><a href="#3-2-交换器的常见类型" class="headerlink" title="3.2 交换器的常见类型"></a>3.2 交换器的常见类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见的交换器类型有: direct、topic、headers 和 fanout</span><br><span class="line"></span><br><span class="line">下面会介绍常见类型的交换器</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-3-交换器的创建"><a href="#3-3-交换器的创建" class="headerlink" title="3.3 交换器的创建"></a>3.3 交换器的创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.exchangeDeclare(&quot;logs&quot;, &quot;fanout&quot;); //使用channel对象创建一个名为logs，类型为fanout交换器</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-4-匿名交换器和临时队列"><a href="#3-4-匿名交换器和临时队列" class="headerlink" title="3.4 匿名交换器和临时队列"></a>3.4 匿名交换器和临时队列</h4><ul>
<li>匿名交换器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面两个例子我们没有使用交换器,但是也可以将消息发送到队列，那是因为我们使用了默认的交换器,交换器名字为空字符串</span><br><span class="line"></span><br><span class="line">代码: channel.basicPublish(&quot;&quot;, &quot;hello&quot;, null, message.getBytes()); 第1个参数空字符串就是交换器名称,现在创建了一个类型为fanout名字为logs的交换器,可以指定交换器的名字了</span><br><span class="line"></span><br><span class="line">代码: channel.basicPublish(&quot;logs&quot;,&quot;&quot;,null,message.getBytes());</span><br></pre></td></tr></table></figure></li>
<li>临时队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们上面的例子在使用队列的时候都会指定一个名字,队列有名字对我们来说是非常重要的因为我们需要为消费者指定同一个队列去消费消息,但是接下来对于我们要完成的日志系统的例子来说指定具体队列不是我们所必须的，我们只关心消息发布出来之后消费者全部都接收到,不需要指定一个具体队列,使用临时队列即可.首先每当我们连接到RabbitMQ的时候需要为我们需要创建一个随机名字的空队列,其次,一旦消费者断开连接,队列将自动删除.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建一个非持久化、独立的、自动删除且名字是随机生成的临时队列的方式: String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">queueName是一个随机队列名 比如生成一个amq.gen-JzTY20BRgKO-HjmUJj0wLg名字</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-5-队列绑定"><a href="#3-5-队列绑定" class="headerlink" title="3.5 队列绑定"></a>3.5 队列绑定</h4><table>
<thead>
<tr>
<th align="center">队列绑定</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://note.youdao.com/yws/api/personal/file/C01B8A01CE52497680E92F5F1D724EA6?method=download&shareKey=526761beb2b1d94d9c53796b8167247a" alt="python-bindings"></td>
</tr>
</tbody></table>
<hr>
<h3 id="第4节-Publish-amp-Subscribe实现"><a href="#第4节-Publish-amp-Subscribe实现" class="headerlink" title="第4节 Publish&amp;Subscribe实现"></a>第4节 Publish&amp;Subscribe实现</h3><blockquote>
<p>练习 消息的发布&#x2F;订阅</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构建一个简单日志系统.它包含2段程序:第一个是消息提供者,将发布日志消息,第二个是消息消费者接受并打印消息,当然需要启动多个消费者,验证多个消费者同时订阅消息,这个模式类似于我们的广播(一个电台播放音乐,每个人订阅这个电台频道,都可以收到这个电台放的音乐,对应我们的需求,就是发布者发布消息,可以被所有的消费者接收到)</span><br><span class="line"></span><br><span class="line">注意: 在启动下面代码示例时,首先要先启动消费者的两个客户端代码,其次启动提供者客户端的代码</span><br></pre></td></tr></table></figure>

<ul>
<li>发布消息(消息提供者)代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发布代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublishMessageLog</span> &#123;</span><br><span class="line">    <span class="comment">//声明需要创建的交换器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建一个名为logs，类型为fanout交换器</span></span><br><span class="line"><span class="comment">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line">        <span class="comment">//向交换器中发送几条消息,我这里循环发送三条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//构建发送的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitMQ &quot;</span>+i;</span><br><span class="line">            <span class="comment">//发送</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;&quot;</span>,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;========消息发布完成========&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生产者声明了一个广播模式的交换器,订阅这个交换器的消费者都可以收到每一条消息.可以看到在生产者中,没有声明队列.这也验证了之前说的.生产者其实只关心exchange,至于exchange会把消息转发给哪些队列,并不是生产者关心的</span><br></pre></td></tr></table></figure>


<ul>
<li>订阅消息(消息消费者)代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在这里使用两个消费者测试,一个消费者将订阅到的消息直接打印到控制台,另一个消费者将订阅到的消息保存为本地日志文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息订阅代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscribeMessageLog1</span> &#123;</span><br><span class="line">    <span class="comment">//声明需要创建的交换器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者客户端1&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建一个名为logs，类型为fanout交换器</span></span><br><span class="line"><span class="comment">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line">        <span class="comment">//声明一个随机队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//将交换器和随机队列绑定到一起</span></span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取订阅到的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;订阅到的消息为: &quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//获取订阅到的消息</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息订阅代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscribeMessageLog2</span> &#123;</span><br><span class="line">    <span class="comment">//声明需要创建的交换器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者客户端2&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建一个名为logs，类型为fanout交换器</span></span><br><span class="line"><span class="comment">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line">        <span class="comment">//声明一个随机队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//将交换器和随机队列绑定到一起</span></span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取订阅到的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            <span class="comment">//将获取到的日志信息保存为本地文件 文件名为abc.log</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;abc.log&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">            fos.write(message.getBytes());</span><br><span class="line">            fos.flush();</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//获取订阅到的消息</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2个消费者,一个打印日志,一个写入文件,消费者实例启动后,会创建一个随机队列,这个在管理页面可以看到(如下图).而消费者实例关闭后,随机队列也会自动删除(所以需要先启动消费者创建随机队列,后启动生产者)</span><br></pre></td></tr></table></figure>

<ul>
<li>管理控制台查看</li>
</ul>
<table>
<thead>
<tr>
<th align="center">管理页面</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://note.youdao.com/yws/api/personal/file/344E988DBA584222AE133C4CE389578D?method=download&shareKey=07e8b064c7affa6f996d5dd8f4be815e" alt="RabbitMQ-info3"></td>
</tr>
</tbody></table>
<hr>
<h2 id="第七章-路由-RabbitMQ-Route"><a href="#第七章-路由-RabbitMQ-Route" class="headerlink" title="第七章 路由(RabbitMQ-Route)"></a>第七章 路由(RabbitMQ-Route)</h2><h3 id="第1节-原理图-2"><a href="#第1节-原理图-2" class="headerlink" title="第1节 原理图"></a>第1节 原理图</h3><table>
<thead>
<tr>
<th align="center">Route</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://note.youdao.com/yws/api/personal/file/27C56AD394AA4B339F170DC425AED42C?method=download&shareKey=a33eda00e49a812cf7238ac294dc4287" alt="python-six"></td>
</tr>
</tbody></table>
<hr>
<h3 id="第2节-Route-路由-介绍"><a href="#第2节-Route-路由-介绍" class="headerlink" title="第2节 Route(路由)介绍"></a>第2节 Route(路由)介绍</h3><ul>
<li>Route的功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在上个消息&quot;发布/订阅&quot;案例中我们建立了一个简单的日志系统,可以广播消息给多个消费者</span><br><span class="line">2. 在这个案例中我们将添加新的特性.我们可以只订阅部分消息.比如:我们的日志分多个级别(info,debug,error)</span><br><span class="line">3. 如果是上面的单纯的&quot;发布/订阅&quot;模式,那么我们会把所有级别的日志都打印到控制台或者保存到本地日志文件中</span><br><span class="line">4. 但是对于有些级别的日志我们不需要保存到本地硬盘,占用空间,这时候就需要对发布者发布的消息进行过滤,进行有针对性的消费,这就需要我们的Route帮助我们完成.</span><br></pre></td></tr></table></figure>
<ul>
<li>交换器的选择</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前面讲到我们的日志系统广播消息给所有的消费者.我们想对其扩展,根据消息的严重性来过滤消息.我们使用的fanout交换器,不能给我们太多的灵活性.它仅仅只是盲目的广播而已.我们使用direct交换器进行代替,其背后的算法很简单,消息会被推送至绑定键(routingKey)和消息发布附带的选择键(routingKey)完全匹配的队列</span><br></pre></td></tr></table></figure>

<ul>
<li>Route的配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 消息发布</span><br><span class="line">    1.1 交换器类型 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT)</span><br><span class="line">    1.2 发布消息的参数 channel.basicPublish(EXCHANGE_NAME,&quot;routingKey&quot;,null,message.getBytes())</span><br><span class="line"></span><br><span class="line">2. 消息订阅</span><br><span class="line">    2.1 交换器类型 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT)</span><br><span class="line">    2.2 队列绑定 channel.queueBind(queueName, EXCHANGE_NAME, severity) //可以进行多重绑定</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第3节-Route-路由-实现"><a href="#第3节-Route-路由-实现" class="headerlink" title="第3节 Route(路由)实现"></a>第3节 Route(路由)实现</h3><ul>
<li>发布消息(消息提供者)代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发布代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublishMessageLog</span> &#123;</span><br><span class="line">    <span class="comment">//声明需要创建的交换器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号,如果不设置为默认值</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建一个名为logs，类型为direct交换器</span></span><br><span class="line"><span class="comment">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            模拟发送多个级别的日志库[info,debug,error]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] severities=&#123;<span class="string">&quot;error&quot;</span>,<span class="string">&quot;info&quot;</span>,<span class="string">&quot;warning&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; severities.length; i++) &#123;</span><br><span class="line">            <span class="comment">//模拟待发送的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitMQ &quot;</span>+i+<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="comment">//发送消息,每次发送之前指定 routingKey: 使用severities里面的值标记每条发送消息的日志级别(就是给每条消息设置路由key)</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,severities[i],<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;========消息发布完成========&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>订阅消息(消息消费者)代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息订阅代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscribeMessageLog1</span> &#123;</span><br><span class="line">    <span class="comment">//声明需要创建的交换器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者客户端1&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建一个名为logs，类型为direct交换器</span></span><br><span class="line"><span class="comment">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明一个随机队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            消费者1采用多重绑定的方式,订阅所有的日志级别的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] severities=&#123;<span class="string">&quot;error&quot;</span>,<span class="string">&quot;info&quot;</span>,<span class="string">&quot;warning&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String severity : severities) &#123;</span><br><span class="line">            channel.queueBind(queueName,EXCHANGE_NAME,severity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取订阅到的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;订阅到的消息为: &quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//获取订阅到的消息</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息订阅代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscribeMessageLog2</span> &#123;</span><br><span class="line">    <span class="comment">//声明需要创建的交换器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者客户端2&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建一个名为logs，类型为direct交换器</span></span><br><span class="line"><span class="comment">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明一个随机队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//消费者2只绑定日志级别为error的消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取订阅到的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            <span class="comment">//将获取到的日志信息保存为本地文件 文件名为abc.log</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;abc.log&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">            fos.write(message.getBytes());</span><br><span class="line">            fos.flush();</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//获取订阅到的消息</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面说了很多,其实就为了做一件事,我们可以使用Direct exchange+routingKey来过滤自己感兴趣的消息,一个队列可以绑定多个routingKey,这就是有选择</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">    1. 启动的时候还是需要先启动消费者端,后启动提供者端</span><br><span class="line">    2. 如果当前路由选择的案例延续使用消息&quot;发布/订阅&quot;案例需要注意不要使用原有的队列,我们新的参数在原有队列不生效</span><br><span class="line">    3. 解决方法,重新声明队列,或者重启RabbitMQ docker容器</span><br><span class="line">        - 关闭容器命令 docker contanier stop &quot;CONTAINER ID&quot;</span><br><span class="line">        - 启动容器命令 docker contanier start &quot;CONTAINER ID&quot;</span><br><span class="line">        - 重启容易命令 docker contanier restart &quot;CONTAINER ID&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第八章-主题-RabbitMQ-Topic"><a href="#第八章-主题-RabbitMQ-Topic" class="headerlink" title="第八章 主题(RabbitMQ-Topic)"></a>第八章 主题(RabbitMQ-Topic)</h2><h3 id="第1节-Topic-主题-原理图"><a href="#第1节-Topic-主题-原理图" class="headerlink" title="第1节 Topic(主题)原理图"></a>第1节 Topic(主题)原理图</h3><table>
<thead>
<tr>
<th align="center">Topic</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://note.youdao.com/yws/api/personal/file/33D7EA24E9394502AF326BEFAEEFC14F?method=download&shareKey=0ca2a435211c05d1c411e24d5cddb2ed" alt="python-serven"></td>
</tr>
</tbody></table>
<hr>
<h3 id="第2节-Topic-主题-介绍"><a href="#第2节-Topic-主题-介绍" class="headerlink" title="第2节 Topic(主题)介绍"></a>第2节 Topic(主题)介绍</h3><ul>
<li>Topic(主题)交换器的功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在上一节中我们使用了direct类型的交换器改进了日志系统,但是还是具有一定的局限性,不能根据多重条件进行路由选择,在我们的日志系统中，我们可能不仅仅根据日志严重性(info/warning/error)订阅日志，也想根据日志来源(auth/cron/kern)订阅日志，这将给我们带来更大的灵活性.比如我们可以订阅auth来源的error级别日志,还可以订阅cron来源的所有级别日志,这就需要我们强大的主题类型的交换器</span><br></pre></td></tr></table></figure>

<ul>
<li>Topic(主题)交换器使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们主题交换器的使用和上面的Route(路由交换器)使用是类似的,都需要指定routingKey,只是发送给主题交换器的消息不能是任意设置的routingKey，必须是用小数点隔开的一系列的标识符.这些标识符可以是随意,但是通常跟消息的某些特性相关联.合法的routingKey 比如&quot;socket.usd.nyse&quot;,&quot;nyse.vmw&quot;,&quot;quick.orange.rabbit&quot;,你愿意用多少单词都可以,只要不超过上限的255个字节,关于routingKey有两种特殊的情况：*(星号)可以代替任意一个标识符; #(井号)可以代替零个或多个标识符(单词)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息发布:</span><br><span class="line"></span><br><span class="line">    1. 交换器设置为topic channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">    2. 构建routingKey并发布 channel.basicPublish(EXCHANGE_NAME,routingKey,null,message.getBytes());</span><br><span class="line"></span><br><span class="line">消息订阅:</span><br><span class="line"></span><br><span class="line">    1. 交换器设置为topic channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">    2. 绑定设置好订阅规则的routingKey channel.queueBind(queueName,EXCHANGE_NAME,routingKey);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第3节-Topic-主题-实现"><a href="#第3节-Topic-主题-实现" class="headerlink" title="第3节 Topic(主题)实现"></a>第3节 Topic(主题)实现</h3><ul>
<li>发布消息(消息提供者)代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发布代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublishMessageLog</span> &#123;</span><br><span class="line">    <span class="comment">//声明需要创建的交换器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号,如果不设置为默认值</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建一个名为logs，类型为topic交换器</span></span><br><span class="line"><span class="comment">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            模拟多个设备[&quot;auth&quot;,&quot;cron&quot;,&quot;kern&quot;]</span></span><br><span class="line"><span class="comment">            模拟级别的日志库[info,debug,error]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] facilities =&#123;<span class="string">&quot;auth&quot;</span>,<span class="string">&quot;cron&quot;</span>,<span class="string">&quot;kern&quot;</span>&#125;;</span><br><span class="line">        String[] severities=&#123;<span class="string">&quot;error&quot;</span>,<span class="string">&quot;info&quot;</span>,<span class="string">&quot;warning&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟发送所有设备(facilities)的所有级别(severities)的日志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; facilities.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;severities.length; j++) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    拼装routingKey</span></span><br><span class="line"><span class="comment">                    格式为: auth.info  auth.waring auth.error</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> facilities[i]+<span class="string">&quot;.&quot;</span>+severities[j];</span><br><span class="line">                <span class="comment">// 设置发送的消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;[&quot;</span>+facilities[i]+<span class="string">&quot;.&quot;</span>+severities[j]+<span class="string">&quot;] Hello RabbitMQ i=&quot;</span> + i;</span><br><span class="line">                <span class="comment">//发送</span></span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME,routingKey,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息提供者发送的日志消息: &quot;</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;========消息发布完成========&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>订阅消息(消息消费者)代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费者1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息订阅代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscribeMessageLog1</span> &#123;</span><br><span class="line">    <span class="comment">//声明需要创建的交换器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者客户端1&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建一个名为logs，类型为topic交换器</span></span><br><span class="line"><span class="comment">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//声明一个随机队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            消费者1采用多重绑定的方式,订阅所有设备的日志级别的信息</span></span><br><span class="line"><span class="comment">            所以我们需要构建routingKey来订阅发布者发布的信息</span></span><br><span class="line"><span class="comment">            使用通配符过滤哪些消息被丢弃，哪些消息被消费打印到控制台</span></span><br><span class="line"><span class="comment">            auth.*    : 订阅auth系统后面是一个单词的日志 比如 auth.info auth.warning auth.error</span></span><br><span class="line"><span class="comment">            *.info    : 订阅info级别的并且前面是一个单词的日志 比如 auth.info等 如果前面有两个单词的如auth.abc.info 不会被订阅到</span></span><br><span class="line"><span class="comment">            #.warning : 订阅所有系统的warning的级别日志，因为#匹配多个单词</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] routingKeys =&#123;<span class="string">&quot;auth.*&quot;</span>,<span class="string">&quot;*.info&quot;</span>,<span class="string">&quot;#.warning&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String routingKey : routingKeys) &#123;</span><br><span class="line">            channel.queueBind(queueName,EXCHANGE_NAME,routingKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取订阅到的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;订阅到的消息为: &quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//获取订阅到的消息</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息订阅代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscribeMessageLog2</span> &#123;</span><br><span class="line">    <span class="comment">//声明需要创建的交换器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者客户端2&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接RabbitMQ服务器的连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.1.129&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接RabbitMQ的服务器AMQP端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建一个名为logs，类型为topic交换器</span></span><br><span class="line"><span class="comment">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//声明一个随机队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//消费者2只订阅 auth系统级别为error的日志消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;auth.error&quot;</span>;</span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取订阅到的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            <span class="comment">//将获取到的日志信息保存为本地文件 文件名为abc.log</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;abc.log&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">            fos.write(message.getBytes());</span><br><span class="line">            fos.flush();</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//获取订阅到的消息</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过上面的例子的结果</span><br><span class="line"></span><br><span class="line">发布者发布的消息:</span><br><span class="line">    消息提供者发送的日志消息: [auth.error] Hello RabbitMQ i=0</span><br><span class="line">    消息提供者发送的日志消息: [auth.info] Hello RabbitMQ i=0</span><br><span class="line">    消息提供者发送的日志消息: [auth.warning] Hello RabbitMQ i=0</span><br><span class="line">    消息提供者发送的日志消息: [cron.error] Hello RabbitMQ i=1</span><br><span class="line">    消息提供者发送的日志消息: [cron.info] Hello RabbitMQ i=1</span><br><span class="line">    消息提供者发送的日志消息: [cron.warning] Hello RabbitMQ i=1</span><br><span class="line">    消息提供者发送的日志消息: [kern.error] Hello RabbitMQ i=2</span><br><span class="line">    消息提供者发送的日志消息: [kern.info] Hello RabbitMQ i=2</span><br><span class="line">    消息提供者发送的日志消息: [kern.warning] Hello RabbitMQ i=2</span><br><span class="line"></span><br><span class="line">消费者1消费的消息:</span><br><span class="line">	将符合routingKey的消息消费了 &#123;&quot;auth.*&quot;,&quot;*.info&quot;,&quot;#.warning&quot;&#125;</span><br><span class="line">	消息如下:</span><br><span class="line">        订阅到的消息为: [auth.error] Hello RabbitMQ i=0</span><br><span class="line">        订阅到的消息为: [auth.info] Hello RabbitMQ i=0</span><br><span class="line">        订阅到的消息为: [auth.warning] Hello RabbitMQ i=0</span><br><span class="line">        订阅到的消息为: [cron.info] Hello RabbitMQ i=1</span><br><span class="line">        订阅到的消息为: [cron.warning] Hello RabbitMQ i=1</span><br><span class="line">        订阅到的消息为: [kern.info] Hello RabbitMQ i=2</span><br><span class="line">        订阅到的消息为: [kern.warning] Hello RabbitMQ i=2</span><br><span class="line"></span><br><span class="line">消费者2消费的消息:</span><br><span class="line">	将符合routingKey的消息消费了 &quot;auth.error&quot;</span><br><span class="line">	消息如下:</span><br><span class="line">		[auth.error] Hello RabbitMQ i=0[auth.error] Hello RabbitMQ i=0</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第九章-SpringBoot整合RabbitMQ"><a href="#第九章-SpringBoot整合RabbitMQ" class="headerlink" title="第九章 SpringBoot整合RabbitMQ"></a>第九章 SpringBoot整合RabbitMQ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建SpringBoot项目,并且选择RabbitMQ的依赖,由于不同的时间段可能SpringBoot和RabbitMQ的版本略微不同</span><br><span class="line"></span><br><span class="line">jdk版本        : 1.8</span><br><span class="line">springboot版本 : 2.1.13.RELEASE</span><br></pre></td></tr></table></figure>

<h3 id="第1节-SpringBoot和RabbitMQ整合并配置"><a href="#第1节-SpringBoot和RabbitMQ整合并配置" class="headerlink" title="第1节 SpringBoot和RabbitMQ整合并配置"></a>第1节 SpringBoot和RabbitMQ整合并配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在application.properties配置文件中配置基本的配置信息</span><br><span class="line"></span><br><span class="line">#设置MQ服务器地址</span><br><span class="line">spring.rabbitmq.host=192.168.1.129</span><br><span class="line">#设置MQ的端口号</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">#开启ACK 自动/手动</span><br><span class="line">spring.jms.listener.acknowledge-mode=auto</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第2节-代码实现"><a href="#第2节-代码实现" class="headerlink" title="第2节 代码实现"></a>第2节 代码实现</h3><h4 id="2-1-不设置交换器"><a href="#2-1-不设置交换器" class="headerlink" title="2.1 不设置交换器"></a>2.1 不设置交换器</h4><ul>
<li>RabbitMQ configuration配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line">    //普通队列名称</span><br><span class="line">    private static final String QUEUE_SIMPLE=&quot;HELLO_QUEUE&quot;;</span><br><span class="line">    //持久化队列名称</span><br><span class="line">    private static final String QUEUE_PERSIST =&quot;WORK_QUEUE&quot;;</span><br><span class="line"></span><br><span class="line">    //创建一个普通队列(非持久化) 导包 org.springframework.amqp.core.Queue 别导错包</span><br><span class="line">    @Bean(&quot;simpleQueue&quot;)</span><br><span class="line">    public Queue createSimpleQueue()&#123;</span><br><span class="line">        return new Queue(QUEUE_SIMPLE,false);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建一个持久化队列</span><br><span class="line">    @Bean(&quot;workQueue&quot;)</span><br><span class="line">    public Queue createWorkQueue()&#123;</span><br><span class="line">        return new Queue(QUEUE_PERSIST,true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息发布和消费</li>
<li><ul>
<li>定义一个User的POJO类用于作为消息发送</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//类一定序列化</span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private Integer userId;</span><br><span class="line">    private String userName;</span><br><span class="line">    private Date createTime;</span><br><span class="line">    private double salary;</span><br><span class="line">    //省略get/set方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>消息发布</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ProducerMessage &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private Queue simpleQueue; //注入配置中的普通队列</span><br><span class="line">    @Resource</span><br><span class="line">    private Queue workQueue;   //注入配置中的持久化队列</span><br><span class="line">    @Resource</span><br><span class="line">    private AmqpTemplate amqpTemplate;// RabbitMQ使用AmqpTemplate进行消息发布</span><br><span class="line">    /**</span><br><span class="line">     * 发送一个User对象到普通队列</span><br><span class="line">     */</span><br><span class="line">    public void sendUser(User user)&#123;</span><br><span class="line">        //指定队列名称</span><br><span class="line">        amqpTemplate.convertAndSend(simpleQueue.getName(),user);</span><br><span class="line">        System.out.println(&quot;消息发送成功...........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 发送一个User集合到持久化队列</span><br><span class="line">     */</span><br><span class="line">    public void sendUserList(List&lt;User&gt; userList)&#123;</span><br><span class="line">        //指定队列名称</span><br><span class="line">        amqpTemplate.convertAndSend(workQueue.getName(),userList);</span><br><span class="line">        System.out.println(&quot;消息发送成功...........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>消息订阅</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConsumerMessage &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 监听消费普通队列的消息</span><br><span class="line">     */</span><br><span class="line">    @RabbitListener(queues = &#123;&quot;HELLO_QUEUE&quot;&#125;)</span><br><span class="line">    public void receiveUser(User user)&#123;</span><br><span class="line">        System.out.println(&quot;接收到的user:&quot;+user);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 监听消费持久化队列里面的消息</span><br><span class="line">     */</span><br><span class="line">    @RabbitListener(queues = &#123;&quot;WORK_QUEUE&quot;&#125;)</span><br><span class="line">    public void receiveUserList(List&lt;User&gt; users)&#123;</span><br><span class="line">        System.out.println(&quot;接收到的users:&quot;+users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>测试</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试的时候只需要测试消息发布，不需要写消息接受的测试,因为消息消费是监听器(RabbitListener),是时时的,在我们发送完成之后，直接就会消费，不需要在写测试类，去消费。</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ProducerMessageTest&#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private ProducerMessage producerMessage;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void sendUser() &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUserId(1001);</span><br><span class="line">        user.setSalary(30000.12);</span><br><span class="line">        user.setUserName(&quot;李雷&quot;);</span><br><span class="line">        user.setCreateTime(new Date());</span><br><span class="line">        producerMessage.sendUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void sendUserList() &#123;</span><br><span class="line">        List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">        User user1 = new User();</span><br><span class="line">        user1.setUserId(1001);</span><br><span class="line">        user1.setSalary(30000.12);</span><br><span class="line">        user1.setUserName(&quot;李雷&quot;);</span><br><span class="line">        user1.setCreateTime(new Date());</span><br><span class="line">        User user2 = new User();</span><br><span class="line">        user2.setUserId(1002);</span><br><span class="line">        user2.setSalary(320000.12);</span><br><span class="line">        user2.setUserName(&quot;李雷2&quot;);</span><br><span class="line">        user2.setCreateTime(new Date());</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        producerMessage.sendUserList(userList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行测试之后的部分日志,可以看到我们运行的提供者，但是消费者的消费消息也打印出来了。</span><br><span class="line">消息发送成功...........</span><br><span class="line">接收到的 users:[User&#123;userId=1001, userName=&#x27;李雷&#x27;, createTime=Fri Apr 03 20:23:00 CST 2020, salary=30000.12&#125;, User&#123;userId=1002, userName=&#x27;李雷2&#x27;, createTime=Fri Apr 03 20:23:00 CST 2020, salary=320000.12&#125;]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-设置交换器"><a href="#2-2-设置交换器" class="headerlink" title="2.2 设置交换器"></a>2.2 设置交换器</h4><ul>
<li>RabbitMQ configuration配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line"></span><br><span class="line">    //队列名称</span><br><span class="line">    private static final String QUEUE_NAME =&quot;queueWork&quot;;</span><br><span class="line">    //交换器名称</span><br><span class="line">    private static final String EXCHANGE_NAME=&quot;LOGS&quot;;</span><br><span class="line">    //声明需要订阅的routingKey类型</span><br><span class="line">    private static final String ROUTING_KEY=&quot;*.error&quot;;</span><br><span class="line"></span><br><span class="line">    //创建一个队列</span><br><span class="line">    @Bean(&quot;queueWork&quot;)</span><br><span class="line">    public Queue createworkQueue()&#123;</span><br><span class="line">        return new Queue(QUEUE_NAME,true);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建一个TOPIC类型交换器</span><br><span class="line">    @Bean(&quot;topicExchange&quot;)</span><br><span class="line">    public TopicExchange createTopicExchange()&#123;</span><br><span class="line">        return new TopicExchange(EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    //将队列、交换器和ROUTING_KEY绑定,如果想绑定多个ROUTING_KEY可以定义多个bindQueueExchageKey方法</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding bindQueueExchageKey()&#123;</span><br><span class="line">        return BindingBuilder.bind(createworkQueue()).to(createTopicExchange()).with(ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息发布和消费</li>
<li><ul>
<li>消息发布</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ProducerMessage &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private Exchange topicExchange;// topic类型的交换器</span><br><span class="line">    @Resource</span><br><span class="line">    private AmqpTemplate amqpTemplate;// 消息处理的对象</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用topic类型交换器</span><br><span class="line">     * 发送多个设备多种类型的消息</span><br><span class="line">     */</span><br><span class="line">    public void sendLevelMessage()&#123;</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app1.info&quot;,&quot;我app1.info下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app1.waring&quot;,&quot;我app1.waring下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app1.error&quot;,&quot;我app1.error下的消息&quot;);</span><br><span class="line"></span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app2.info&quot;,&quot;我app2.info下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app2.waring&quot;,&quot;我app2.waring下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app2.error&quot;,&quot;我app2.error下的消息&quot;);</span><br><span class="line"></span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app3.info&quot;,&quot;我app3.info下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app3.waring&quot;,&quot;我app3.waring下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app3.error&quot;,&quot;我app3.error下的消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>消息消费</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConsumerMessage &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 消费消息</span><br><span class="line">     */</span><br><span class="line">    @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">            value = @Queue(value = &quot;queueWork&quot;),</span><br><span class="line">            exchange = @Exchange(value = &quot;topicExchange&quot;)))</span><br><span class="line">    public void receiveErrorLogs(Message message)&#123;</span><br><span class="line">        System.out.println(&quot;获取到的error消息为:&quot;+ new String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>测试<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ProducerMessageTest&#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private ProducerMessage producerMessage;</span><br><span class="line">    @Test</span><br><span class="line">    public void sendLevelMessage()&#123;</span><br><span class="line">        producerMessage.sendLevelMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//日志中的打印结果:</span><br><span class="line">/**</span><br><span class="line"> * 获取到的error消息为:我app1.error下的消息</span><br><span class="line"> * 获取到的error消息为:我app2.error下的消息</span><br><span class="line"> * 获取到的error消息为:我app3.error下的消息</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="第十章-RabbitMQ事务-amp-Confirm"><a href="#第十章-RabbitMQ事务-amp-Confirm" class="headerlink" title="第十章 RabbitMQ事务&amp;Confirm"></a>第十章 RabbitMQ事务&amp;Confirm</h2><h3 id="第1节-RabbitMQ事务机制"><a href="#第1节-RabbitMQ事务机制" class="headerlink" title="第1节 RabbitMQ事务机制"></a>第1节 RabbitMQ事务机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过上面的学习大家都知道我们的RabbitMQ的队列是可以持久化保存数据的，就算我们的MQ服务器挂掉或者重启也不会造成数据丢失,但是如果我们的消息还没有到队列就丢失了怎么办呢？</span><br><span class="line"></span><br><span class="line">2. 接下来我们就说一下RabbitMQ怎么解决这个问题,如果不做任何配置的情况下我们使用消息提供者发布消息,消息发布完成之后其实提供者是不知道消息发送是否成功的,是否正确到达broker的，RabbitMQ提供了两种方式来解决这个问题:</span><br><span class="line"></span><br><span class="line">    第1种: 通过AMQP事务机制实现</span><br><span class="line">    第2种: 通过将channel设置成confirm模式来实现</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第2节-AMQP事物机制"><a href="#第2节-AMQP事物机制" class="headerlink" title="第2节 AMQP事物机制"></a>第2节 AMQP事物机制</h3><h4 id="2-1-AMQP事物机制介绍"><a href="#2-1-AMQP事物机制介绍" class="headerlink" title="2.1 AMQP事物机制介绍"></a>2.1 AMQP事物机制介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该模式与数据库的事务非常相似。RabbitMQ中与事务机制有关的方法有txSelect(),txCommit()以及txRollback()。txSelect用于将当前channel设置成transaction模式，txCommit用于提交事务，txRollback用于回滚事务。在通过txSelect开启事务之后，我们便可以发布消息给broker了，如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-AMQP事物机制实现"><a href="#2-2-AMQP事物机制实现" class="headerlink" title="2.2 AMQP事物机制实现"></a>2.2 AMQP事物机制实现</h4><ul>
<li>代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ProducerAMQP &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个持久化队列</span><br><span class="line">        channel.queueDeclare(&quot;AMQP_QUEUE&quot;,true,false,false,null);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //创建消息</span><br><span class="line">            String message=&quot;AMQP事物消息&quot;;</span><br><span class="line">            //开启事务</span><br><span class="line">            channel.txSelect();</span><br><span class="line">            //发布消息</span><br><span class="line">            channel.basicPublish(&quot;&quot;,&quot;AMQP_QUEUE&quot;,true, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());</span><br><span class="line">            //用于测试的异常</span><br><span class="line">            int i=1/0;</span><br><span class="line">            //提交事务</span><br><span class="line">            channel.txCommit();</span><br><span class="line">            System.out.println(&quot;消息发送成功...........&quot;);</span><br><span class="line">        &#125;catch (RuntimeException e)&#123;</span><br><span class="line">            System.out.println(&quot;消息发送失败...........&quot;);</span><br><span class="line">            //回滚事务</span><br><span class="line">            channel.txRollback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">该模式用法简单,但是有个致命的缺点,那就是事务提交非常慢,会严重降低系统吞吐量,所以一般不推荐使用该模式,而改用confirm模式</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-Confirm机制"><a href="#第3节-Confirm机制" class="headerlink" title="第3节 Confirm机制"></a>第3节 Confirm机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Confirm发送方确认模式使用和事务类似,也是通过设置Channel进行发送方确认的,并且Confirm支持异步.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Confirm的三种实现方式:</span><br><span class="line">方式一: channel.waitForConfirms()普通发送方确认模式</span><br><span class="line">方式二: channel.waitForConfirmsOrDie()批量确认模式</span><br><span class="line">方式三: channel.addConfirmListener()异步监听发送方确认模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们这里只演示最后一种常用的异步监听发送方式:</span><br><span class="line">    - 消息发布者发布多条消息,并使用异步监听</span><br><span class="line">    - 消息订阅者消息确认模式(ack)采用手动模式</span><br><span class="line">    - prefetch设置为1，限制通道上未完成的发送消息数量</span><br></pre></td></tr></table></figure>

<ul>
<li>消息提供者代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ProducerConfirm &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个持久化队列</span><br><span class="line">        channel.queueDeclare(&quot;CONFIRM_QUEUE&quot;,true,false,false,null);</span><br><span class="line">        //开启发送方确认模式</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        //发送消息</span><br><span class="line">        //创建消息</span><br><span class="line">        String message = &quot;Hello RabbitMQ Confirm &quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;,&quot;CONFIRM_QUEUE&quot;,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());</span><br><span class="line">        System.out.println(&quot;发送消息为: &quot;+message);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //监听发送状态</span><br><span class="line">        channel.addConfirmListener(new ConfirmListener() &#123;</span><br><span class="line">            /*</span><br><span class="line">                消息确认成功</span><br><span class="line">                deliveryTag: 如果发送多条，这是最后一条消息的deliveryTag</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public void handleAck(long deliveryTag, boolean multiple) throws IOException &#123;</span><br><span class="line">                System.out.println(&quot;已确认消息: &quot;+deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            //消息确认异常</span><br><span class="line">            @Override</span><br><span class="line">            public void handleNack(long deliveryTag, boolean multiple) throws IOException &#123;</span><br><span class="line">                System.out.println(&quot;未确认消息: &quot;+deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>消息消费者代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConsumerConfirm &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个持久化队列</span><br><span class="line">        channel.queueDeclare(&quot;CONFIRM_QUEUE&quot;,true,false,false,null);</span><br><span class="line">        //设置prefetch</span><br><span class="line">        int prefetch=1;</span><br><span class="line">        channel.basicQos(prefetch);</span><br><span class="line">        //消费消息</span><br><span class="line">        boolean autoAck = false; //关闭消息的自动确认</span><br><span class="line">        channel.basicConsume(&quot;CONFIRM_QUEUE&quot;, autoAck, new DeliverCallback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handle(String consumerTag, Delivery message) throws IOException &#123;</span><br><span class="line">                //获取消息内容</span><br><span class="line">                byte[] body = message.getBody();</span><br><span class="line">                System.out.println(&quot;消息已被消费: &quot;+new String(body));</span><br><span class="line">                //获取消息序号</span><br><span class="line">                long deliveryTag = message.getEnvelope().getDeliveryTag();</span><br><span class="line">                System.out.println(&quot;消息已被消费 deliveryTag: &quot;+deliveryTag);</span><br><span class="line">                /*</span><br><span class="line">                    手动确认此序号的消息</span><br><span class="line">                    multiple:如果设置为false那么只确认当前程序的消息,如果设置为true，确认当前序号之前的所有消息</span><br><span class="line">                 */</span><br><span class="line">                channel.basicAck(deliveryTag,true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, (consumerTag) -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上为RabbitMQ的常见操作,信息来源于官网,如果有什么翻译或者讲解错误,欢迎发送邮件指正.</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>Layui快速入门</title>
    <url>/2024/05/03/web/Layui%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者: 夜泊1990</span><br><span class="line">企鹅: 1611756908</span><br><span class="line">鹅群: 948233848</span><br><span class="line">邮箱: hd1611756908@163.com</span><br><span class="line">博客: https://hd1611756908.github.io/</span><br><span class="line">B 站: https://space.bilibili.com/514155929/</span><br></pre></td></tr></table></figure>

<h2 id="第一章-Layui是什么"><a href="#第一章-Layui是什么" class="headerlink" title="第一章 Layui是什么"></a>第一章 Layui是什么</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Layui 是一套免费的开源 Web UI 组件库,遵循原生态的 HTML/CSS/JavaScript 开发模式,极易上手,拿来即用</span><br><span class="line"></span><br><span class="line">学习框架的意义: 写更少的代码,实现相同的功能.</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="第二章-Layui环境搭建"><a href="#第二章-Layui环境搭建" class="headerlink" title="第二章 Layui环境搭建"></a>第二章 Layui环境搭建</h2><h3 id="第1节-官网地址"><a href="#第1节-官网地址" class="headerlink" title="第1节 官网地址"></a>第1节 官网地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/</span><br><span class="line"></span><br><span class="line">当前版本 2.9.x 版本,相比于2.8.x和2.7.x新增了很多实用功能,下面会介绍.</span><br></pre></td></tr></table></figure>

<h3 id="第2节-环境搭建"><a href="#第2节-环境搭建" class="headerlink" title="第2节 环境搭建"></a>第2节 环境搭建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一 : 在线第三方 CDN 引入,UNPKG 和 CDNJS 均为第三方免费 CDN (详细请看官网)</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入 layui.css --&gt;</span><br><span class="line">    &lt;link href=&quot;//unpkg.com/layui@2.9.7/dist/css/layui.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;!-- 引入 layui.js --&gt;</span><br><span class="line">    &lt;script src=&quot;//unpkg.com/layui@2.9.7/dist/layui.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">方式二 : 离线引入</span><br><span class="line"></span><br><span class="line">	离线引入方式需要去官网下载layui安装包,将css文件和js文件复制粘贴到项目中,然后在引入</span><br><span class="line">	下载地址: https://foruda.gitee.com/attach_file/1709083131303683727/layui-v2.9.7.zip?token=4d86625f99f8aa72a6131358c786aeb4&amp;ts=1709353417&amp;attname=layui-v2.9.7.zip</span><br><span class="line"></span><br><span class="line">方式三 : npm 引入(略)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 前端模板如下: --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>layui<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 layui.css --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;//unpkg.com/layui@2.9.7/dist/css/layui.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 你的 HTML 代码 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入 layui.js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/layui@2.9.7/dist/layui.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="第三章-Layui知识点大纲"><a href="#第三章-Layui知识点大纲" class="headerlink" title="第三章 Layui知识点大纲"></a>第三章 Layui知识点大纲</h2><table>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEBa5414dbd90479d79d9a5a9539ee12e0d?method=download&shareKey=4b8d238ab4f7e8c12ad2310701d2c067">
        </td>
    </tr>
    <tr>
        <td style="font-size:14px;">
            大纲中只列举了常用的Layui前端知识点,其它的请查看官网.
        </td>
    </tr>
</table>



<h2 id="第四章-Layui页面元素"><a href="#第四章-Layui页面元素" class="headerlink" title="第四章 Layui页面元素"></a>第四章 Layui页面元素</h2><h3 id="第1节-布局元素"><a href="#第1节-布局元素" class="headerlink" title="第1节 布局元素"></a>第1节 布局元素</h3><h4 id="1-1-栅格布局"><a href="#1-1-栅格布局" class="headerlink" title="1.1 栅格布局"></a>1.1 栅格布局</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/layout/grid.html</span><br></pre></td></tr></table></figure>

<ul>
<li>案例展示</li>
</ul>
<table>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEBec329b24422feb6d79299856f591445d?method=download&shareKey=50201b0b98fed97eaf5b30be3509dfbc">
        </td>
    </tr>
</table>


<ul>
<li>传统布局(略)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用传统布局实现案例样式代码量会比较多</span><br></pre></td></tr></table></figure>

<ul>
<li>Layui布局</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Layui布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 引入 layui.css --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;//unpkg.com/layui@2.9.7/dist/css/layui.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 布局容器,水平居中  --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-container&quot;</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-row&quot;</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-col-md3&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 350px;border: 1px solid #ccc;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-col-md9&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 350px;border: 1px solid royalblue;&quot;</span>&gt;</span></span><br><span class="line">				  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-row&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 45px;border: 1px solid red;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-row&quot;</span>&gt;</span></span><br><span class="line">				  	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-col-md9&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 303px;border: 1px solid fuchsia;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-col-md3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 引入 layui.js --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/layui@2.9.7/dist/layui.js</span></span></span><br><span class="line"><span class="string"><span class="tag">	&lt;/body&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">&lt;/html&gt;</span></span></span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEB523a50d186bcf3f3f1e30e4106e209a1?method=download&shareKey=484d05317dd2b41e30bc9ee3439eb558">
        </td>
    </tr>
</table>


<h4 id="1-2-布局容器"><a href="#1-2-布局容器" class="headerlink" title="1.2 布局容器"></a>1.2 布局容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/layout/grid.html#container</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 宽度固定水平居中 */</span><br><span class="line">&lt;div class=&quot;layui-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">/* 宽度100% */</span><br><span class="line">&lt;div class=&quot;layui-fluid&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="第2节-表格"><a href="#第2节-表格" class="headerlink" title="第2节 表格"></a>第2节 表格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/table/</span><br></pre></td></tr></table></figure>

<h3 id="第3节-按钮-x2F-图标"><a href="#第3节-按钮-x2F-图标" class="headerlink" title="第3节 按钮&#x2F;图标"></a>第3节 按钮&#x2F;图标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/button/</span><br><span class="line">https://layui.dev/docs/2/icon/</span><br></pre></td></tr></table></figure>

<h3 id="第4节-表单"><a href="#第4节-表单" class="headerlink" title="第4节 表单"></a>第4节 表单</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/form/</span><br></pre></td></tr></table></figure>


<h3 id="第5节-其它"><a href="#第5节-其它" class="headerlink" title="第5节 其它"></a>第5节 其它</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">动画、导航、菜单等...</span><br></pre></td></tr></table></figure>

<h2 id="第五章-Layui内置模块"><a href="#第五章-Layui内置模块" class="headerlink" title="第五章 Layui内置模块"></a>第五章 Layui内置模块</h2><h3 id="第1节-分页模块"><a href="#第1节-分页模块" class="headerlink" title="第1节 分页模块"></a>第1节 分页模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/laypage/</span><br></pre></td></tr></table></figure>

<h3 id="第2节-数据表格"><a href="#第2节-数据表格" class="headerlink" title="第2节 数据表格"></a>第2节 数据表格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/table/</span><br></pre></td></tr></table></figure>
<h3 id="第3节-弹出层"><a href="#第3节-弹出层" class="headerlink" title="第3节 弹出层"></a>第3节 弹出层</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/layer/</span><br></pre></td></tr></table></figure>
<h3 id="第4节-表单模块"><a href="#第4节-表单模块" class="headerlink" title="第4节 表单模块"></a>第4节 表单模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/form/</span><br></pre></td></tr></table></figure>
<h3 id="第5节-时间模块"><a href="#第5节-时间模块" class="headerlink" title="第5节 时间模块"></a>第5节 时间模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/laydate/</span><br></pre></td></tr></table></figure>
<h3 id="第6节-文件上传模块"><a href="#第6节-文件上传模块" class="headerlink" title="第6节 文件上传模块"></a>第6节 文件上传模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://layui.dev/docs/2/upload/</span><br></pre></td></tr></table></figure>
<h3 id="第7节-树状表格模块"><a href="#第7节-树状表格模块" class="headerlink" title="第7节 树状表格模块"></a>第7节 树状表格模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式 1 : layui2.7版本不带树状表格,需要借助第三方   https://dev.layuion.com/extend/</span><br><span class="line">方式 2 : layui2.8/9版本新增树状表格,使用起来更方便   https://layui.dev/docs/2/treeTable/</span><br></pre></td></tr></table></figure>

<h3 id="第8节-其它模块"><a href="#第8节-其它模块" class="headerlink" title="第8节 其它模块"></a>第8节 其它模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以上介绍的模块是开发中常见的模块,如果想使用其它模块,请查看官网</span><br></pre></td></tr></table></figure>

<h2 id="第六章-Layui框架案例练习"><a href="#第六章-Layui框架案例练习" class="headerlink" title="第六章 Layui框架案例练习"></a>第六章 Layui框架案例练习</h2><h3 id="第1节-SQL语句"><a href="#第1节-SQL语句" class="headerlink" title="第1节 SQL语句"></a>第1节 SQL语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE book <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> UTF8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> category(</span><br><span class="line">    category_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;分类ID&#x27;</span>,</span><br><span class="line">    category_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类名称&#x27;</span></span><br><span class="line">) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span><span class="string">&#x27;UTF8&#x27;</span> AUTO_INCREMENT<span class="operator">=</span><span class="number">10000</span> COMMENT <span class="string">&#x27;图书分类表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> category(category_name) <span class="keyword">VALUES</span>(<span class="string">&#x27;科技&#x27;</span>),(<span class="string">&#x27;文学&#x27;</span>),(<span class="string">&#x27;历史&#x27;</span>),(<span class="string">&#x27;财经&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建图书表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">    book_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;图书ID&#x27;</span>,</span><br><span class="line">    book_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图书名称&#x27;</span>,</span><br><span class="line">    author_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图书作者&#x27;</span>,</span><br><span class="line">    price <span class="keyword">DOUBLE</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0.00</span> COMMENT <span class="string">&#x27;图书价格&#x27;</span>,</span><br><span class="line">    category_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类ID,关联分类表主键&#x27;</span>,</span><br><span class="line">    create_time DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    status <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;是否上架 1:上架 0:下架&#x27;</span>,</span><br><span class="line">    book_url <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图书主图地址&#x27;</span>,</span><br><span class="line">    book_address <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;真实地址&#x27;</span></span><br><span class="line">) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span><span class="string">&#x27;UTF8&#x27;</span> AUTO_INCREMENT<span class="operator">=</span><span class="number">10000</span> COMMENT <span class="string">&#x27;图书表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关联</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (category_id) <span class="keyword">REFERENCES</span> category(category_id);</span><br></pre></td></tr></table></figure>

<h3 id="第2节-页面展示"><a href="#第2节-页面展示" class="headerlink" title="第2节 页面展示"></a>第2节 页面展示</h3><table>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEBcaa39e034539b0436c60175c4bc15f87?method=download&shareKey=5251378f90ebd97962429356230647af">
        </td>
    </tr>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEBfeb4a5ed6e47f0cff0af91fa4e2223c1?method=download&shareKey=80b34117c9de27640bd38f3fc42ab33c">
        </td>
    </tr>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEB1277a1620a1118934e164d8013075215?method=download&shareKey=7899d9be3b1c64ff16c4543a37f67577">
        </td>
    </tr>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEBbee41cf043b4124b0f2ff952d80420df?method=download&shareKey=beb1c52915054fdd7d901edd3e22b3f9">
        </td>
    </tr>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEBaed2d0b4ae0699e1456d033316e79bf9?method=download&shareKey=40a5537004c56713eca6ff7d5d5cc6bd">
        </td>
    </tr>
</table>


<h2 id="第七章-Layui框架模板使用-Pear-Admin-Layui"><a href="#第七章-Layui框架模板使用-Pear-Admin-Layui" class="headerlink" title="第七章 Layui框架模板使用(Pear Admin Layui)"></a>第七章 Layui框架模板使用(Pear Admin Layui)</h2><h3 id="第1节-官网地址-1"><a href="#第1节-官网地址-1" class="headerlink" title="第1节 官网地址"></a>第1节 官网地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.pearadmin.com/</span><br></pre></td></tr></table></figure>

<h3 id="第2节-在线演示地址"><a href="#第2节-在线演示地址" class="headerlink" title="第2节 在线演示地址"></a>第2节 在线演示地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://layui.pearadmin.com/</span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEB1fc5dd0f446c590b847196457a44446e?method=download&shareKey=5e20f7c11b7c1038647a4a906598c93b">
        </td>
    </tr>
</table>


<h3 id="第2节-CRUD练习"><a href="#第2节-CRUD练习" class="headerlink" title="第2节 CRUD练习"></a>第2节 CRUD练习</h3><h4 id="2-1-数据库表创建"><a href="#2-1-数据库表创建" class="headerlink" title="2.1 数据库表创建"></a>2.1 数据库表创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建测试库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE auth <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> UTF8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 常见角色表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> role(</span><br><span class="line">    role_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">    role_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色名称&#x27;</span>,</span><br><span class="line">    status TINYINT(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态(定义逻辑删除) 1:有效 0:无效&#x27;</span></span><br><span class="line">) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span><span class="string">&#x27;UTF8&#x27;</span> AUTO_INCREMENT<span class="operator">=</span><span class="number">10000</span> COMMENT <span class="string">&#x27;角色表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(</span><br><span class="line">    user_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    user_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">    status TINYINT(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态(定义逻辑删除) 1:有效 0:无效&#x27;</span></span><br><span class="line">) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span><span class="string">&#x27;UTF8&#x27;</span> AUTO_INCREMENT<span class="operator">=</span><span class="number">10000</span> COMMENT <span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户角色关联表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_role(</span><br><span class="line">    role_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>  COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">    user_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    status TINYINT(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态(定义逻辑删除) 1:有效 0:无效&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(role_id,user_id)</span><br><span class="line">) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span><span class="string">&#x27;UTF8&#x27;</span> AUTO_INCREMENT<span class="operator">=</span><span class="number">10000</span> COMMENT <span class="string">&#x27;用户角色关联表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外键关联</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> user_role <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (role_id) <span class="keyword">REFERENCES</span> role(role_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> user_role <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (user_id) <span class="keyword">REFERENCES</span> <span class="keyword">user</span>(user_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 菜单表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> menu(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;菜单ID&#x27;</span>,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单标题&#x27;</span>,</span><br><span class="line">    icon  <span class="type">VARCHAR</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;菜单图标&#x27;</span>,</span><br><span class="line">    type <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;菜单类型&#x27;</span>,</span><br><span class="line">    open_type <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> &quot;&quot; COMMENT &quot;菜单类型名称&quot;,</span><br><span class="line">    href <span class="type">VARCHAR</span>(<span class="number">255</span>) COMMENT &quot;菜单指向地址&quot;,</span><br><span class="line">    parent_id <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT &quot;菜单父ID,关联主键&quot;,</span><br><span class="line">    level <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT &quot;菜单级别&quot;,</span><br><span class="line">    status TINYINT <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT &quot;菜单状态 1:有效 0:禁用&quot;,</span><br><span class="line">    update_time <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;设置当前时间，并且自动更更新时间&#x27;</span></span><br><span class="line">) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span><span class="string">&#x27;UTF8&#x27;</span> AUTO_INCREMENT<span class="operator">=</span><span class="number">10000</span> COMMENT <span class="string">&#x27;用户角色关联表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 菜单角色关联表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> menu_role(</span><br><span class="line">    role_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>  COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单ID&#x27;</span>,</span><br><span class="line">    status TINYINT(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态(定义逻辑删除) 1:有效 0:无效&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(role_id,id)</span><br><span class="line">) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span><span class="string">&#x27;UTF8&#x27;</span> AUTO_INCREMENT<span class="operator">=</span><span class="number">10000</span> COMMENT <span class="string">&#x27;菜单角色关联表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外键关联</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> menu_role <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (role_id) <span class="keyword">REFERENCES</span> role(role_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> menu_role <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (id) <span class="keyword">REFERENCES</span> menu(id);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-页面展示"><a href="#2-2-页面展示" class="headerlink" title="2.2 页面展示"></a>2.2 页面展示</h4>]]></content>
      <categories>
        <category>Layui</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>JavaScript</tag>
        <tag>Layui</tag>
        <tag>pearAdmin</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-admin-template快速入门</title>
    <url>/2024/06/16/web/vue-admin-template%E7%AE%80%E5%8D%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者: 夜泊1990</span><br><span class="line">企鹅: 1611756908</span><br><span class="line">鹅群: 948233848</span><br><span class="line">邮箱: hd1611756908@163.com</span><br><span class="line">博客: https://hd1611756908.github.io/</span><br><span class="line">B 站: https://space.bilibili.com/514155929/</span><br></pre></td></tr></table></figure>

<h2 id="第一章-模板介绍"><a href="#第一章-模板介绍" class="headerlink" title="第一章 模板介绍"></a>第一章 模板介绍</h2><h3 id="第1节-vue-element-admin概述"><a href="#第1节-vue-element-admin概述" class="headerlink" title="第1节 vue-element-admin概述"></a>第1节 vue-element-admin概述</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网地址: https://panjiachen.github.io/vue-element-admin-site/zh/</span><br><span class="line"></span><br><span class="line">是一个前端模版,可以帮助前端开发者快速构建管理系统的前端页面</span><br><span class="line"></span><br><span class="line">模板中提供了 【登录 / 注销】【权限验证】【多环境发布】【全局功能】【编辑器/Excel】... 等常见功能</span><br><span class="line"></span><br><span class="line">样式如下: ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span><br></pre></td></tr></table></figure>



<span id="more"></span>



<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd40f111969498907c275bd47dee662ec?method=download&shareKey=7d61f238d36c3e69aeb03a58cb0b48ae" alt="vue"></p>
<h3 id="第2节-vue-admin-template概述"><a href="#第2节-vue-admin-template概述" class="headerlink" title="第2节 vue-admin-template概述"></a>第2节 vue-admin-template概述</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">vue-admin-template是vue-element-admin的简洁版</span><br><span class="line">在实际开发中,vue-element-admin里的很多功能都不是我们想要的</span><br><span class="line">所以作者基于vue-element-admin进行了删减,vue-admin-template版本适合开发</span><br><span class="line">如果想使用vue-element-admin里面的某些功能,可以去复制和粘贴.</span><br></pre></td></tr></table></figure>

<h3 id="第3节-源码地址"><a href="#第3节-源码地址" class="headerlink" title="第3节 源码地址"></a>第3节 源码地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue-element-admin地址:</span><br><span class="line">	GITEE: https://gitee.com/panjiachen/vue-element-admin.git</span><br><span class="line">	GITHUB: https://github.com/PanJiaChen/vue-element-admin.git</span><br><span class="line">vue-admin-template地址:</span><br><span class="line">	GITEE: https://gitee.com/panjiachen/vue-admin-template.git</span><br><span class="line">	GITHUB: https://github.com/PanJiaChen/vue-admin-template.git</span><br></pre></td></tr></table></figure>

<h2 id="第二章-下载和运行"><a href="#第二章-下载和运行" class="headerlink" title="第二章 下载和运行"></a>第二章 下载和运行</h2><h3 id="第1节-系统环境"><a href="#第1节-系统环境" class="headerlink" title="第1节 系统环境"></a>第1节 系统环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我个人本地环境</span><br><span class="line"></span><br><span class="line">操作系统: Windows 11 教育版</span><br><span class="line">node:    v20.13.0   官网要求版本&#123; node: &#x27;8 || 10 || 12 || 14 || 16 || 17&#x27; &#125; 但是v20.13.0也可以</span><br><span class="line">npm:     10.5.2 </span><br><span class="line">vue-cli: @vue/cli 5.0.8</span><br><span class="line"></span><br><span class="line">npm包镜像站地址: https://npmmirror.com/</span><br><span class="line"></span><br><span class="line">因为国外镜像源地址下载容易失败,可以切换成国内的镜像源</span><br><span class="line"></span><br><span class="line">1. 查看镜像源命令:  npm config list</span><br><span class="line">2. 设置镜像源命令:  npm config set registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line">注意: 不允许使用cnpm进行依赖下载</span><br></pre></td></tr></table></figure>

<h3 id="第2节-依赖下载和运行"><a href="#第2节-依赖下载和运行" class="headerlink" title="第2节 依赖下载和运行"></a>第2节 依赖下载和运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">依赖下载和:</span><br><span class="line">	第一步: 打开命令行工具</span><br><span class="line">	第二步: 切换到项目的根目录</span><br><span class="line">	第三步: 在命令行输入 npm install 命令</span><br><span class="line">	第四步: 等待依赖安装完成</span><br><span class="line">	第五步: 在命令行输入  npm run dev 启动运行</span><br></pre></td></tr></table></figure>

<h2 id="第三章-目录结构介绍"><a href="#第三章-目录结构介绍" class="headerlink" title="第三章 目录结构介绍"></a>第三章 目录结构介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">略 请参考 vue-cli脚手架的官网: https://cli.vuejs.org/zh/</span><br></pre></td></tr></table></figure>

<h2 id="第四章-左侧菜单名称以及图标修改"><a href="#第四章-左侧菜单名称以及图标修改" class="headerlink" title="第四章 左侧菜单名称以及图标修改"></a>第四章 左侧菜单名称以及图标修改</h2><h3 id="第1节-菜单名称修改"><a href="#第1节-菜单名称修改" class="headerlink" title="第1节 菜单名称修改"></a>第1节 菜单名称修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左侧菜单名称是在路由配置中生成的  文件位置: vue-admin-template\src\router\index.js</span><br><span class="line"></span><br><span class="line">修改title属性的值就是对应着左侧菜单的名称显示</span><br></pre></td></tr></table></figure>

<img src="https://note.youdao.com/yws/api/personal/file/WEB962f59d88c36b6cb76394b70545dca67?method=download&shareKey=604d1722e6f45626d4a0c7052960f1d1" alt="vue-admin-02" />

<h3 id="第2节-菜单图标修改"><a href="#第2节-菜单图标修改" class="headerlink" title="第2节 菜单图标修改"></a>第2节 菜单图标修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左侧菜单中的图标是在路由配置中生成的  文件位置: vue-admin-template\src\router\index.js</span><br><span class="line"></span><br><span class="line">修改icon属性的值就可以修改图标了</span><br><span class="line">icon的值可以使用element-ui官网提供的图标显示,如果想定制化图标,可以参考官网: https://panjiachen.github.io/vue-element-admin-site/</span><br></pre></td></tr></table></figure>

<img src="https://note.youdao.com/yws/api/personal/file/WEBf8ff376348617ea8581d8eeda0e27a60?method=download&shareKey=9dacfa40d03d5f2a5b7b920ebb449b0f" alt="vue-admin-03" />

<h2 id="第五章-面包屑导航名称不一致修改"><a href="#第五章-面包屑导航名称不一致修改" class="headerlink" title="第五章 面包屑导航名称不一致修改"></a>第五章 面包屑导航名称不一致修改</h2><img src="https://note.youdao.com/yws/api/personal/file/WEBe98538afb8c80609b3d5cfd32acafa18?method=download&shareKey=94619cd32d4775d24fb75811d88568cc" alt="vue-admin-04" />



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">修改菜单之后,面包屑导航菜单和首页名称不一致</span><br><span class="line"></span><br><span class="line">修改文件位置: vue-admin-template\src\components\Breadcrumb\index.vue</span><br><span class="line"></span><br><span class="line">修改如下: 👇👇👇👇👇</span><br></pre></td></tr></table></figure>

<img src="https://note.youdao.com/yws/api/personal/file/WEB74e3dddff3dec344e5e739cf566c10cf?method=download&shareKey=1c24776b5f88b62a913e70d492b69a52" alt="vue-admin-05" style="zoom:100%;" />

<h2 id="第六章-浏览器选项卡标题名称修改"><a href="#第六章-浏览器选项卡标题名称修改" class="headerlink" title="第六章 浏览器选项卡标题名称修改"></a>第六章 浏览器选项卡标题名称修改</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe986b0f5befbb3a2ae4802db83964e9e?method=download&shareKey=965e0019a774451ec1cb8c3d032960d0" alt="vue"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器选项卡标题修改文件位置: vue-admin-template\src\settings.js</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5ee0c76c04b0c7e42559d025472e4985?method=download&shareKey=4bbd2df365848712edfdda7c43be0381" alt="vue"></p>
<h2 id="第七章-标签导航实现"><a href="#第七章-标签导航实现" class="headerlink" title="第七章 标签导航实现"></a>第七章 标签导航实现</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBb3db6adcab7bace31e1c1d4288943e71?method=download&shareKey=a85d41db232ccbab97511ccdf4f645d5" alt="vue"></p>
<hr>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2ad5f7e8df21d9de6b0c0e00b9bf8b61?method=download&shareKey=5560c0ef3544410569a34c1e33966720" alt="vue"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue-admin-template默认情况下是没有标签导航的,如果想实现标签导航,需要去vue-element-admin项目中复制</span><br><span class="line"></span><br><span class="line">步骤如下:</span><br><span class="line"></span><br><span class="line">第一步: 去vue-element-admin项目中复制标签导航的功能组件</span><br><span class="line">	文件位置: vue-element-admin\src\layout\components\TagsView </span><br><span class="line">	将TagsView文件夹整个复制到vue-admin-template对应的目录中</span><br><span class="line"></span><br><span class="line">第二步: 复制配置文件</span><br><span class="line">	文件位置:</span><br><span class="line">		vue-element-admin\src\store\modules\tagsView.js</span><br><span class="line">		vue-element-admin\src\store\modules\permission.js</span><br><span class="line">	复制到vue-admin-template对应的目录下</span><br><span class="line"></span><br><span class="line">第三步: 修改配置文件,详细修改如下</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个文件 vue-element-admin\src\layout\index.vue</li>
</ul>
<img src="https://note.youdao.com/yws/api/personal/file/WEB2bcbcb16ad68501a928cf847152d8288?method=download&shareKey=d35ab066bdf54f4d99d5c6918e91a30b" alt="vue" style="zoom:80%;" />

<ul>
<li>第二个文件 vue-admin-template\src\layout\components\index.js</li>
</ul>
<img src="https://note.youdao.com/yws/api/personal/file/WEBf0c4d438dedb62e0faaf472f3d66fc8c?method=download&shareKey=68ee161ce86652471902dc95533bd546" style="zoom:80%;" />

<ul>
<li>第三个文件 vue-admin-template\src\store\index.js</li>
</ul>
<img src="https://note.youdao.com/yws/api/personal/file/WEBc656dfc0b1bc9e77a5e43e8354857c34?method=download&shareKey=033f68d21834c7becdb6d077e9e536ec" alt="vue" style="zoom:100%;" />

<ul>
<li>第四个文件 vue-admin-template\src\store\getters.js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个文件内容可以去vue-element-admin中去复制</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB29d834311db51cea37fff3245da1b57b?method=download&shareKey=25ccc629ad1673ebad5f76982552445f" alt="vue"></p>
<ul>
<li>第五个文件  vue-admin-template\src\layout&#x2F;components&#x2F;AppMain.vue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个文件的内容可以去vue-element-admin中去复制</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb3e5a2b8f017222d155f1f0b3dcf1735?method=download&shareKey=2bf7c6b5cdbeec73d4af361425ac6dec" alt="vue"></p>
<ul>
<li>第六个文件(钉) vue-admin-template\src\router\index.js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个一定要配置,否则当标签实现的时候，当用户把标签全部删除没了之后会报404,所以必须得留下一个标签,所以需要钉一下</span><br><span class="line"></span><br><span class="line">这个需要看你需要将哪个标签固定下来,关闭不掉即可.配置方式见下图</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa7ca763e0c87ebbba76a39f2cc2fc1d3?method=download&shareKey=3dd1741793fcbe71a6fff00d42e0102f" alt="vue"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置affix: true 参数，首页就会被固定住,此标签不会被关闭掉. 见下图</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe5e415d4c88cbbba965c27d05d4b7f13?method=download&shareKey=7494b431a3f7ab7b333fb875f624d9a6" alt="vue"></p>
<h2 id="第八章-标签导航经控制台警告处理"><a href="#第八章-标签导航经控制台警告处理" class="headerlink" title="第八章 标签导航经控制台警告处理"></a>第八章 标签导航经控制台警告处理</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1635e599ef6ddd68908e142497698219?method=download&shareKey=a0fb210714bd1b34cc2808f511791d6f" alt="vue"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制台出现警告的原因是因为在 vue-admin-template\src\store\modules\permission.js 文件中没有找到asyncRoutes变量</span><br><span class="line"></span><br><span class="line">这个变量需要在vue-admin-template\src\router\index.js文件中声明,所在此文件中暂时先声明一个asyncRoutes变量,是一个数组</span><br><span class="line"></span><br><span class="line">export const asyncRoutes = [] 可以解决,后面在说这个变量的意义.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>element</tag>
        <tag>vue-element-admin</tag>
        <tag>vue-admin-template</tag>
      </tags>
  </entry>
  <entry>
    <title>01-Java入门必读</title>
    <url>/2024/06/15/javase/01-Java%E5%85%A5%E9%97%A8%E5%BF%85%E8%AF%BB/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者: 夜泊1990</span><br><span class="line">企鹅: 1611756908</span><br><span class="line">鹅群: 948233848</span><br><span class="line">邮箱: hd1611756908@163.com</span><br><span class="line">博客: https://hd1611756908.github.io/</span><br><span class="line">B 站: https://space.bilibili.com/514155929/</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学习计算机语言,首先要了解计算机,然后了解计算机软件,最后开始我们的计算机语言之旅.</span><br><span class="line"></span><br><span class="line">软件是用计算机语言编写,软件运行在计算机上. 为了更好的学习计算机语言,所以从计算机学习开始 ...</span><br></pre></td></tr></table></figure>
<span id="more"></span>]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Javase</tag>
        <tag>计算机语言</tag>
        <tag>面向对象语言</tag>
      </tags>
  </entry>
  <entry>
    <title>02-计算机与计算机语言概述</title>
    <url>/2024/06/15/javase/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者: 夜泊1990</span><br><span class="line">企鹅: 1611756908</span><br><span class="line">鹅群: 948233848</span><br><span class="line">邮箱: hd1611756908@163.com</span><br><span class="line">博客: https://hd1611756908.github.io/</span><br><span class="line">B 站: https://space.bilibili.com/514155929/</span><br></pre></td></tr></table></figure>

<h2 id="第一章-计算机概述"><a href="#第一章-计算机概述" class="headerlink" title="第一章 计算机概述"></a>第一章 计算机概述</h2><h3 id="第1节-计算机概念"><a href="#第1节-计算机概念" class="headerlink" title="第1节 计算机概念"></a>第1节 计算机概念</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">广义:</span> <span class="string">凡是可以帮助我们完成计算的工具统称为计算机【帮助完成计算的机器】(比如</span> <span class="string">算盘、计算器等...)</span></span><br><span class="line"><span class="string">狭义:</span> <span class="string">当前我们所谓的计算机一般情况特指电子计算机(集运算、办公、娱乐于一身...)</span></span><br></pre></td></tr></table></figure>
<h3 id="第2节-计算机组成"><a href="#第2节-计算机组成" class="headerlink" title="第2节 计算机组成"></a>第2节 计算机组成</h3><span id="more"></span>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">计算机组成:</span></span><br><span class="line">  <span class="string">硬件:</span> <span class="string">主板、硬盘、CPU、显卡、显示器、鼠标、键盘...</span></span><br><span class="line"></span><br><span class="line">  <span class="string">软件:</span></span><br><span class="line">    <span class="string">系统软件:</span> <span class="string">Windows、Linux、Mac、Android、ios...</span></span><br><span class="line">    <span class="string">应用软件:</span> <span class="string">QQ</span> <span class="string">微信</span> <span class="string">王者荣耀</span> <span class="string">英雄联盟(LOL)</span> <span class="string">开心消消乐</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<h3 id="第3节-计算机简史"><a href="#第3节-计算机简史" class="headerlink" title="第3节 计算机简史"></a>第3节 计算机简史</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span> <span class="string">很久以前</span> <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">算盘(机械/手动)</span> </span><br><span class="line">	</span><br><span class="line">	<span class="number">1.1</span> <span class="string">作者</span>    <span class="string">:</span> <span class="string">不详</span></span><br><span class="line">	<span class="number">1.2</span> <span class="string">出生年代:</span> <span class="string">不详</span></span><br><span class="line">	<span class="number">1.3</span> <span class="string">备注:</span> <span class="string">我国第一颗原子弹的很多数据是采用算盘计算出来的,据说当初的草稿可以铺满整个罗布泊.在这里致敬老一辈科学家</span></span><br><span class="line">	</span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">步进计算器(机械/手动)</span></span><br><span class="line"></span><br><span class="line">	<span class="number">2.1</span> <span class="string">作者</span>    <span class="string">:</span> <span class="string">德国数学家[戈特弗里德·布莱尼茨]</span></span><br><span class="line">	<span class="number">2.2</span> <span class="string">出生年代:</span> <span class="number">1694</span><span class="string">年</span></span><br><span class="line">	<span class="number">2.3</span> <span class="string">备注:</span> <span class="string">当前模型存在于德意志博物馆中</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="string">差分机(机械/手动)</span></span><br><span class="line"></span><br><span class="line">	<span class="number">3.1</span> <span class="string">作者</span>    <span class="string">:</span> <span class="string">英国数学家[查尔斯·巴贝奇]</span></span><br><span class="line">	<span class="number">3.2</span> <span class="string">出生年代:</span> <span class="number">1822</span><span class="string">年</span></span><br><span class="line">	<span class="number">3.3</span> <span class="string">备注:</span> <span class="string">历时10年从设计到加工都是由巴贝奇一个人完成,计算精度达到6位小数</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span><span class="string">.</span> <span class="string">分析机(机械/自动[蒸汽机])</span></span><br><span class="line"></span><br><span class="line">	<span class="number">4.1</span> <span class="string">作者</span>    <span class="string">:</span> <span class="string">英国数学家[查尔斯·巴贝奇]</span></span><br><span class="line">	<span class="number">4.2</span> <span class="string">出生年代:</span> <span class="number">1830</span><span class="string">年</span></span><br><span class="line">	<span class="number">4.3</span> <span class="string">备注:</span> <span class="string">可以进行相当复杂的运算,精确到小数点后31位,采用蒸汽机驱动,打孔卡带(存储器的前身)编程,算是世界上第一台真正意义上的计算机(巴贝奇被后人称之为计算机之父)</span></span><br><span class="line">			  <span class="string">由于设计太超前没有被大多数人认可.但是当时有一位英国数学家</span> <span class="string">奥古斯塔·阿达·金(勒芙蕾丝伯爵夫人)</span> <span class="string">对分析机特别感兴趣,并为其写了一个算法(第一位给计算机写程序的人).</span> </span><br><span class="line"></span><br><span class="line"><span class="number">5</span><span class="string">.</span> <span class="string">打孔计数器(机械/电动)</span></span><br><span class="line"></span><br><span class="line">	<span class="number">5.1</span> <span class="string">作者</span>    <span class="string">:</span> <span class="string">美国人[赫尔曼·霍尔瑞斯]</span></span><br><span class="line">	<span class="number">5.2</span> <span class="string">出生年代:</span> <span class="number">1880</span><span class="number">-1890</span><span class="string">年</span></span><br><span class="line">	<span class="number">5.3</span> <span class="string">备注:</span> <span class="string">最早用于1890年的美国人口普查,1890年以前美国人口普查人数统计采用纯手动,1890之后进入电器自动化时代,原理就是将人的信息通过打孔的方式记录到纸卡上,通过打孔卡计数器读取.</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span><span class="string">.</span> <span class="string">阿塔纳索夫-贝瑞计算机(ABC计算机[电子管])</span></span><br><span class="line"></span><br><span class="line">	<span class="number">6.1</span> <span class="string">作者</span>    <span class="string">:</span> <span class="string">美国科学家[阿塔纳索夫]</span> <span class="string">和</span> <span class="string">克利福德·贝里[当时正在物理系读研究生]</span></span><br><span class="line">	<span class="number">6.2</span> <span class="string">出生年代:</span> <span class="number">1939</span><span class="string">年(样机问世)1942年(测试成功)</span></span><br><span class="line">	<span class="number">6.3</span> <span class="string">备注:</span> <span class="string">爱荷华州立大学</span> <span class="string">物理系任副教授,在给学生上课时需要给学生讲授如何求解</span> <span class="string">线性偏微分方程组</span> <span class="string">他觉得比较浪费时间还枯燥,所以用了两年时间搞了这台机器</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span><span class="string">.</span> <span class="string">电子数字积分计算机(ENIAC[电子管])</span></span><br><span class="line"></span><br><span class="line">	<span class="number">7.1</span> <span class="string">作者</span>    <span class="string">:</span> <span class="string">团队[约翰·冯·诺依曼和&quot;莫尔小组&quot;的工程师</span> <span class="string">埃克特、莫希利、戈尔斯坦</span> <span class="string">以及华人科学家</span> <span class="string">朱传榘[jǔ]</span> <span class="string">组成]</span></span><br><span class="line">	<span class="number">7.2</span> <span class="string">出生年代:</span> <span class="number">1946</span><span class="string">年</span></span><br><span class="line">	<span class="number">7.3</span> <span class="string">备注:</span> <span class="string">研发背景:</span> <span class="string">二战时期</span></span><br><span class="line">			  <span class="string">研发原因:</span> <span class="string">二战时期主要战力飞机和大炮,所以研发新型大炮和导弹十分重要,为此美国陆军军械部设立了弹道研究室,美国军方要求该实验室每天为陆军炮弹部队提供6张射表.</span></span><br><span class="line">			  <span class="string">当时的射表数据是纯人工计算,效率低下,数据不准确,几百个人加班加点两个多月才能算出一张射表(每张射表计算几百个弹道数据).</span></span><br><span class="line">			  <span class="string">研发时间:</span> <span class="string">宾夕法尼亚大学莫尔电机工程学院的莫希利于1942年提出了试制第一台电子计算机的初始设想(这台计算机的设想来源于阿塔纳索夫-贝瑞计算机)</span></span><br><span class="line">			  <span class="string">计算速度:</span> <span class="string">每秒能进行5000次加法运算,每秒400次乘法运算,它还能进行平方和立方运算，计算正弦和余弦等三角函数的值及其它一些更复杂的运算</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span><span class="string">.</span> <span class="string">电子计算机(集成电路)</span></span><br><span class="line"></span><br><span class="line">	<span class="number">8.1</span> <span class="string">作者</span>    <span class="string">:</span> <span class="string">当代科学家</span></span><br><span class="line">	<span class="number">8.2</span> <span class="string">出生年代:</span> <span class="string">当代</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span> <span class="string">以后</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<table>
    <tbody>
        <tr>
            <td>
                <img src="https://note.youdao.com/yws/api/personal/file/WEB063fa14676e78193c22adba80b1a4ee9?method=download&shareKey=5b68bc6d1ffa50ec33e47f16005f498a">
            </td>
        </tr>
    </tbody>
</table>


<h2 id="第二章-计算机语言概述"><a href="#第二章-计算机语言概述" class="headerlink" title="第二章 计算机语言概述"></a>第二章 计算机语言概述</h2><h3 id="第1节-自然语言和计算机语言"><a href="#第1节-自然语言和计算机语言" class="headerlink" title="第1节 自然语言和计算机语言"></a>第1节 自然语言和计算机语言</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">自然语言</span>  <span class="string">:</span> <span class="string">人与人沟通的语言叫做自然语言;</span> <span class="string">比如:</span> <span class="string">汉语、英语、韩语...</span></span><br><span class="line"><span class="string">计算机语言:</span> <span class="string">人与计算机沟通的语言叫做计算机语言;</span> <span class="string">比如:</span> <span class="string">C/C++、Java、Python...</span></span><br><span class="line"></span><br><span class="line"><span class="string">计算机语言也叫做语言,被人类划分到语言的行列说明它和我们人类的自然语言有很多相似之处.</span></span><br><span class="line"></span><br><span class="line"><span class="string">自然语言和计算机语言学习步骤:</span></span><br><span class="line">	<span class="string">自然语言(英语)</span>  <span class="string">:</span> <span class="string">单词</span>         <span class="string">--</span> <span class="string">语法</span> <span class="string">--</span> <span class="string">与外国人交流</span></span><br><span class="line">	<span class="string">计算机语言(Java):</span> <span class="string">关键字(单词)</span>  <span class="string">--</span> <span class="string">语法</span> <span class="string">--</span> <span class="string">与计算机交流</span></span><br><span class="line"></span><br><span class="line"><span class="string">计算机语言学习起来更简单,因为计算机语言没有英语那么多单词,只需要记住常见的几十个,常用的十几二十个即可.</span></span><br></pre></td></tr></table></figure>

<h3 id="第2节-计算机语言由来"><a href="#第2节-计算机语言由来" class="headerlink" title="第2节 计算机语言由来"></a>第2节 计算机语言由来</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">计算机语言不是随着计算机的发展而发展的,其实计算机语言最早的应用不是在计算机上而是在织布机上,你没看错就是那个男耕女织的织布机上.</span></span><br><span class="line"></span><br><span class="line"><span class="number">1800</span><span class="string">到1804年法国人</span> <span class="string">约瑟夫·玛丽·雅卡尔</span> <span class="string">在改进前人提花机(能织出带图案的织布机)的基础之上,发明了采用穿孔卡带的方式,来记录提花机提花的过程,可以达到让提花机可以重复提花的目的.</span></span><br><span class="line"></span><br><span class="line"><span class="string">这里的穿孔卡带(纸卡):</span> <span class="string">可以看成是最早期的计算机存储</span></span><br><span class="line"><span class="string">纸卡上的孔:</span> <span class="string">最早期的与机器交流的语言(早期计算机语言),有孔的地方为1</span> <span class="string">无孔的地方为0</span></span><br><span class="line"></span><br><span class="line"><span class="string">提花机根据读取带孔的纸卡来控制顶针的抬起或者是放下而进行提花.</span></span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td style="text-align:center;"><img style="width:50%;" src="https://note.youdao.com/yws/api/personal/file/WEB3d62b69f9ec4f70b29f681ec55ca7579?method=download&shareKey=186236fd8188c75879784e15ebb3fb96"></td>
        <td style="width:50%;"><iframe src="//player.bilibili.com/player.html?aid=969922335&bvid=BV1hp4y1Y7y5&cid=246572512&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></td>
    </tr>
</table>


<h3 id="第3节-计算机存储器发展"><a href="#第3节-计算机存储器发展" class="headerlink" title="第3节 计算机存储器发展"></a>第3节 计算机存储器发展</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">在学习计算机语言之前首先我们需要先聊一聊存储器(类似于计算机的硬盘,或者U盘这一类存储设备),因为计算机软件都安装在电脑硬盘上,</span></span><br><span class="line"><span class="string">计算机软件是由计算机语言编写的,总结计算机语言编写的软件最终要保存在电脑的硬盘上,以便于计算机进行读取和运行.</span></span><br></pre></td></tr></table></figure>

<table>
    <tbody>
        <tr>
            <td style="word-wrap:break-word;width:50%;">
                <strong>穿孔卡带</strong>
                <pre style="font-size:12px;">
1830年最早应用在巴贝尔的分析机上.
这是最早的计算机软硬件结合.
这个纸卡就是最早期的计算机存储器.
纸卡上的孔就是最早期的计算机编程语言(0/1)
计算机读取这个卡,其实就是读取卡上的孔,获取要完成的任务信息.
这样带孔的卡不仅可以做计算机存储,还可以做其他存储(例如太阳卡,做学生饭卡)
                </pre>
            </td>
            <td style="width:50%;">
                <img src="https://note.youdao.com/yws/api/personal/file/WEB5f4dfe24e4d9d17be7bb4465dfa204be?method=download&shareKey=b1326d0daed574cdb689724a94299cab">
            </td>
        </tr>
        <tr>
            <td style="word-wrap:break-word;width:50%;">
                <strong>电子管存储</strong>
                <pre style="font-size:12px;">
世界上第一台计算机[ABC计算机],就是采用电子管存储
相比于纸带,电子管存储造价昂贵,故障率高,但是可以反复擦除
                </pre>
            </td>
            <td style="width:50%;">
                <img src="https://note.youdao.com/yws/api/personal/file/WEB7eb88e30e3459ae5eddbc7279fa58968?method=download&shareKey=481f4d3cca91861b8baa0640ec41bf7c">
            </td>
        </tr>
        <tr>
            <td style="word-wrap:break-word;width:50%;">
                <strong>磁带</strong>
                <pre style="font-size:12px;">
1950年IBM最早把盘式磁带用在数据存储上.
一卷磁带可以代替1万张打孔纸卡,既便宜还能减少卡带体积
成为直到80年代最为普及的计算机存储设备
                </pre>
            </td>
            <td style="width:50%;">
                <img src="https://note.youdao.com/yws/api/personal/file/WEBf2fb95b33eaa280fcaab8f9dd1028103?method=download&shareKey=4c9ebb1c3e005bf862393092520b5407">
            </td>
        </tr>
        <tr>
            <td style="word-wrap:break-word;width:50%;">
                <strong>磁鼓</strong>
                <pre style="font-size:12px;">
1953年,第一台磁鼓应用于IBM701
磁鼓是利用铝鼓筒表面涂覆的磁性材料来存储数据的
鼓筒旋转速度很高,因此存取速度快
                </pre>
            </td>
            <td style="width:50%;">
                <img src="https://note.youdao.com/yws/api/personal/file/WEB5327a14b0ef235f74cae99323d7fcae2?method=download&shareKey=ac25c1206ab772557a15bce9fcc182a1">
            </td>
        </tr>
        <tr>
            <td style="word-wrap:break-word;width:50%;">
                <strong>软盘</strong>
                <pre style="font-size:12px;">
1969年第一张软盘诞生,当时是一张8英寸的大家伙,可以保存80K的只读数据
1973年的时候比他小一号但是容量为256k的软盘诞生,并且是可读写的
直到90年代末,那时候可以找到3.5英寸250MB的的软盘
                </pre>
            </td>
            <td style="width:50%;">
                <img src="https://note.youdao.com/yws/api/personal/file/WEB7852c3552b2481958348ab1e03cf818a?method=download&shareKey=b54d21fab1d71febcb356ca2ac35ea94">
            </td>
        </tr>
        <tr>
            <td style="word-wrap:break-word;width:50%;">
                <strong>硬盘</strong>
                <pre style="font-size:12px;">
1956年9月13日,IBM发布了305 RAMAC硬盘机
在当时的存储容量可以达到惊人的4.4MB
当时一个硬盘机的重量高达600公斤以上
                </pre>
            </td>
            <td style="width:50%;">
                <img src="https://note.youdao.com/yws/api/personal/file/WEB9f940e972cf40af6d8c567252d99f5c8?method=download&shareKey=6d535472b124989adae8b42b66f75173">
            </td>
        </tr>
        <tr>
            <td style="word-wrap:break-word;width:50%;">
                <strong>光盘</strong>
                <pre style="font-size:12px;">
1958年开始发明光盘技术到1972年第一张光盘问世
1978年才在市场上售卖,在当时光盘是只读的不能写
                </pre>
            </td>
            <td style="width:50%;">
                <img src="https://note.youdao.com/yws/api/personal/file/WEB0de12ec3d4f7a7003781c7bcec41eb7e?method=download&shareKey=50f810bd3db30ef76b06e341da6d7624">
            </td>
        </tr>
        <tr>
            <td style="word-wrap:break-word;width:50%;">
                <strong>固态硬盘</strong>
                <pre style="font-size:12px;">
1989年世界上第一款固态硬盘由IBM推出
                </pre>
            </td>
            <td style="width:50%;">
                <img src="https://note.youdao.com/yws/api/personal/file/WEBd8139ea2a0b3e6ffdfd7e5a5415e91cb?method=download&shareKey=3927d2b18a87dc669f82f911fe1f422a">
            </td>
        </tr>
    </tbody>
</table>


<h3 id="第4节-计算机语言发展"><a href="#第4节-计算机语言发展" class="headerlink" title="第4节 计算机语言发展"></a>第4节 计算机语言发展</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">第一代计算机语言(机器语言)</span> <span class="string">--</span> <span class="string">第二代计算机语言(汇编语言)</span> <span class="string">--</span> <span class="string">第三代计算机语言(C/C++、Java、Python...)</span></span><br></pre></td></tr></table></figure>

<h4 id="4-1-第一代计算机语言"><a href="#4-1-第一代计算机语言" class="headerlink" title="4.1 第一代计算机语言"></a>4.1 第一代计算机语言</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">第一代计算机语言我们称它为机器语言,直接与机器交互,控制机器行为</span></span><br><span class="line"></span><br><span class="line"><span class="string">比如提花机,使用穿孔纸卡保存花样,控制提花机的顶针</span></span><br><span class="line"></span><br><span class="line"><span class="string">百合花</span>  <span class="string">--</span>  <span class="string">对应一卷纸</span></span><br><span class="line"><span class="string">玫瑰花</span>  <span class="string">--</span>  <span class="string">对应一卷纸</span></span><br><span class="line"><span class="string">牡丹花</span>  <span class="string">--</span>  <span class="string">对应一卷纸</span></span><br><span class="line"></span><br><span class="line"><span class="string">在纸上记录花样使用孔洞来记录,如果有孔顶针穿过,没有孔顶针穿不过,这时候纸带上只有两种状态</span> <span class="number">0</span><span class="string">/1</span> </span><br><span class="line"></span><br><span class="line"><span class="string">机器语言(第一代计算机语言)使用钻孔编程,或者是使用0和1进行编程,有孔表示1没有孔表示0</span></span><br><span class="line"></span><br><span class="line"><span class="string">早期计算机都是使用穿孔卡带进行存储的穿孔卡带可以存花样,也可以存算法,数据等.计算机通过读纸带然后执行纸带中记录的功能.</span></span><br><span class="line"></span><br><span class="line"><span class="string">雅卡尔提花机工作原理:</span></span><br><span class="line"><span class="string">https://v.qq.com/x/page/x0553c41d57.html</span></span><br></pre></td></tr></table></figure>

<table>
    <tbody>
        <tr>
            <td style="width:50%;" > <img src="https://note.youdao.com/yws/api/personal/file/WEBc18fc7f8931a3d01851978570456e792?method=download&shareKey=73481797e5bbe21d10d91ece819bc3f6"> </td>
            <td style="width:50%;" > <iframe style="width:100%;"  frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=x0553c41d57" allowFullScreen="true"></iframe> </td>
        </tr>
    </tbody>
</table>

<h4 id="4-2-第二代计算机语言"><a href="#4-2-第二代计算机语言" class="headerlink" title="4.2 第二代计算机语言"></a>4.2 第二代计算机语言</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">随着计算机的发展,随着存储的发展,我们需要计算机做的事情越来越复杂,这时候使用机器语言(类似于打孔,给机器输入0/1)编程越来越复杂.</span></span><br><span class="line"><span class="string">这是就催生出了计算机语言的发展,咱们下面举一个例子</span></span><br><span class="line"></span><br><span class="line"><span class="string">让计算机帮助我们计算</span> <span class="number">1</span><span class="string">+1</span> </span><br><span class="line"><span class="string">如果打孔的话，下面随便举的一个例子</span> <span class="number">0</span><span class="string">代表纸带没有孔,1代表纸带有孔</span></span><br><span class="line"><span class="number">00000001</span>  <span class="string">--</span> <span class="number">1</span></span><br><span class="line"><span class="number">10101010</span>  <span class="string">--</span> <span class="string">+</span>   <span class="string">ADD</span> <span class="string">(使用我们熟悉的字符序列代替了一串0和1)</span></span><br><span class="line"><span class="number">00000001</span>  <span class="string">--</span> <span class="number">1</span></span><br><span class="line"><span class="number">00000010</span>  <span class="string">--</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="string">除了0就是1一个功能由很多0和1组成,这样的功能代码很不容易记忆,所以就有人提出想法,能不能有什么办法使用我们熟悉的字符代替0和1,所以汇编语言出现了</span></span><br></pre></td></tr></table></figure>

<table>
    <tbody>
        <tr>
            <td>
                <strong>汇编语言</strong>
                <pre>
使用简单的英文符号,代替了大量的0/1机器码
相比于机器语言,汇编语言编写代码更容易.
                </pre>
            </td>
            <td> <img src="https://note.youdao.com/yws/api/personal/file/WEB831fe058bc913dc50d369f38d6fc3cff?method=download&shareKey=0b7a757f63297fe12876d44d6d8f5f48"> </td>
        </tr>
    </tbody>
</table>
<table>
    <tr>
        <img src="https://note.youdao.com/yws/api/personal/file/WEBcc448a91d115a8966209d1c665dfc705?method=download&shareKey=65939636371d03d77641c16885f6b895">
    </tr>
</table>

<h4 id="4-3-第三代计算机语言"><a href="#4-3-第三代计算机语言" class="headerlink" title="4.3 第三代计算机语言"></a>4.3 第三代计算机语言</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">第三代计算机语言我们管它叫高级语言,是因为语言发展到现阶段,语言中增加和修改了很多字符序列,在汇编语言中加法运算还需要使用ADD,在高级语言(C语言)中,加法运算就和我们数学中的运算差不多使用+(加号),第三代的计算机语言的很多字符比较贴近于我们的日常.</span></span><br><span class="line"></span><br><span class="line"><span class="string">虽然语言表层是我们熟悉的字符序列,但是底层计算机在运行的时候还是解析成0/1(因为计算机底层原理不会变),这时就需要计算机对语言进行转换.将高级语言转成机器语言</span></span><br><span class="line"></span><br><span class="line"><span class="string">催生了各种语言编译器的发展(这里不做详细讲解).</span></span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td> <img src="https://note.youdao.com/yws/api/personal/file/WEBd261c18db0c16e124f8f43ad44e0ac79?method=download&shareKey=da7f2db899d1edd5aa79c13319b27cce"> </td>
    </tr>
</table>

<h3 id="第5节-进制-了解"><a href="#第5节-进制-了解" class="headerlink" title="第5节 进制(了解)"></a>第5节 进制(了解)</h3><h4 id="5-1-人类计数方式"><a href="#5-1-人类计数方式" class="headerlink" title="5.1 人类计数方式"></a>5.1 人类计数方式</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">我们人类在日常生活中进行计数的方式采用的是(1,2,3,4,...,8,9,10....) 逢十进一,这种累计计数的方式称之为 十进制 计数</span><br></pre></td></tr></table></figure>
<h4 id="5-2-计算机计数方式"><a href="#5-2-计算机计数方式" class="headerlink" title="5.2 计算机计数方式"></a>5.2 计算机计数方式</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">计算机的计数方式和人类的计数方式是完全不一样的,因为其底层只有类似于低电平和高电平的开关量,只能用开关量进行计数(高电平(ON)为1/低电平(OFF)为0)</span><br><span class="line"></span><br><span class="line">在单位的长度的位数时,人类的计数方式可以记录更大的数</span><br><span class="line"></span><br><span class="line">例如: 以三位为例 人类可以存放数字范围为: 0-999  而计算机在正常情况下三位最多存储111,变成十进制就是 0-7 </span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEB3e33f1ab281f2c33f93bb7a5e8cd4462?method=download&shareKey=873a689031366aa1e7eb4db3b3eaa29d">
        </td>
    </tr>
</table>

<h4 id="5-3-进制的转换"><a href="#5-3-进制的转换" class="headerlink" title="5.3 进制的转换"></a>5.3 进制的转换</h4><h5 id="5-3-1-常见进制介绍"><a href="#5-3-1-常见进制介绍" class="headerlink" title="5.3.1 常见进制介绍"></a>5.3.1 常见进制介绍</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">常见进制介绍</span><br><span class="line">1. (十进制)人类日常计算进制</span><br><span class="line">2. (二进制)计算机底层计算进制</span><br><span class="line">3. (八进制/十六进制)主要配合二进制使用,二进制位数太多不好记录(用来进行存储记忆)</span><br><span class="line"></span><br><span class="line">注意:虽然计算机底层是以二进制的形式存在,但是它是以补码的方式存储数据,这里不做介绍.</span><br></pre></td></tr></table></figure>
<h5 id="5-3-2-常见进制转换"><a href="#5-3-2-常见进制转换" class="headerlink" title="5.3.2 常见进制转换"></a>5.3.2 常见进制转换</h5><table>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEB8378e2962d3aade9a730e167323dc81d?method=download&shareKey=5d92d80a83ce616aaeef40acae9513d6">
        </td>
    </tr>
</table>

<h2 id="第三章-计算机操作系统概述"><a href="#第三章-计算机操作系统概述" class="headerlink" title="第三章 计算机操作系统概述"></a>第三章 计算机操作系统概述</h2><h3 id="第1节-操作系统介绍"><a href="#第1节-操作系统介绍" class="headerlink" title="第1节 操作系统介绍"></a>第1节 操作系统介绍</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. 操作系统概念: </span><br><span class="line">	操作系统（operating system，简称OS）是管理计算机硬件与软件资源的计算机程序.也是一个使用计算机语言编写的软件.</span><br><span class="line">	</span><br><span class="line">2. 操作系统的功能</span><br><span class="line">	2.1 是整个计算机硬件和软件资源的超级大管家,管理着当前计算机的软硬件资源</span><br><span class="line">	2.2 硬件管理主要包括 </span><br><span class="line">		① CPU和内存资源的合理分配</span><br><span class="line">		② 任务优先级的控制</span><br><span class="line">		③ 其他输入输出设备的管理(网络,usb,显示器等)...</span><br><span class="line">	2.3 软件管理</span><br><span class="line">		① 多软件应用的运行</span><br><span class="line">		② 软硬件资源合理化分配(例如打开QQ软件需要内存怎么分配)等...</span><br></pre></td></tr></table></figure>

<h3 id="第2节-操作系统发展"><a href="#第2节-操作系统发展" class="headerlink" title="第2节 操作系统发展"></a>第2节 操作系统发展</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">无操作系统 -- ... -- DOS -- windows/unix/Linux</span><br><span class="line"></span><br><span class="line">无操作系统时代: 计算机控制的硬件资源比较少,没有复杂的任务调度问题.</span><br><span class="line"></span><br><span class="line">	算盘             -- 人脑就是CPU,珠子就是存储器     -- 算盘是主力人脑辅助  -- 半人脑，半工具</span><br><span class="line">	步进计算器/差分机  -- 解放人脑(里面有自己的计算方式)  -- 手动运行,机器运算  -- 解放人脑,没有解放双手</span><br><span class="line"></span><br><span class="line">有操作系统时代: 当一台计算机需要干的工作越来越多并且逻辑越来越复杂的时候,这时候就需要一个管理者来管理这些任务,并且合理分配计算机硬件资源.</span><br><span class="line">	分析机           -- 蒸汽机运行,机器运算,读卡       -- 解放人脑,解放双手</span><br><span class="line">	打孔计数器        -- 电动运行,机器运算,读卡        -- 比分析机更先进</span><br><span class="line">	电子计算机        -- 当前大规模集成电路            -- 超高的运算速度</span><br><span class="line">	</span><br><span class="line">注意: 这里可以将穿孔卡片看成最古老的操作系统(也可以把其单纯的看成一个软件),控制着计算机运行.</span><br></pre></td></tr></table></figure>

<h2 id="第四章-DOS操作系统概述"><a href="#第四章-DOS操作系统概述" class="headerlink" title="第四章 DOS操作系统概述"></a>第四章 DOS操作系统概述</h2><h3 id="第1节-DOS操作系统介绍"><a href="#第1节-DOS操作系统介绍" class="headerlink" title="第1节 DOS操作系统介绍"></a>第1节 DOS操作系统介绍</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. 磁盘操作系统(Disk Operating System)是早期个人计算机上的一类操作系统</span><br><span class="line">2. DOS系统没有图形化操作界面,要想使用需要学习dos命令</span><br><span class="line">3. 直到windows/mac等带有图形化操作界面的系统出现,dos才慢慢的退出历史舞台</span><br><span class="line">4. 但是DOS操作系统没有被取消掉,而是以一个应用软件的方式与其它操作系统共存(例如 在windows下作为windows下的应用软件与windows系统共存)</span><br></pre></td></tr></table></figure>
<h3 id="第2节-DOS操作系统的启动方式"><a href="#第2节-DOS操作系统的启动方式" class="headerlink" title="第2节 DOS操作系统的启动方式"></a>第2节 DOS操作系统的启动方式</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">在windows下的启动方式:</span><br><span class="line">	方式一: 快捷键 [开始+r],开启一个黑色的命令行窗口,说明DOS启动成功</span><br><span class="line">	方式二: win10 可以使用搜索框直接输入cmd然后回车唤出黑色的命令行窗口</span><br><span class="line"></span><br><span class="line">注意: 我们把DOS常常叫做命令行窗口,所以后面我说DOS或者命令行属于一个意思.</span><br></pre></td></tr></table></figure>
<h3 id="第3节-DOS操作系统的常用命令"><a href="#第3节-DOS操作系统的常用命令" class="headerlink" title="第3节 DOS操作系统的常用命令"></a>第3节 DOS操作系统的常用命令</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">dir : 列出当前目录下的文件或文件夹</span><br><span class="line">md  : 创建目录</span><br><span class="line">rd  : 删除目录</span><br><span class="line">cd  : 进入到指定目录</span><br><span class="line">cd..: 返回上一级目录</span><br><span class="line">cd / : 切换到根目录</span><br><span class="line">del : 删除文件</span><br><span class="line">exit: 退出DOS命令行</span><br><span class="line">cls : 清屏</span><br><span class="line"></span><br><span class="line">以上是DOS操作系统下的简单命令操作.后续一些其它命令在介绍.</span><br></pre></td></tr></table></figure>
<hr>
<div style="font-size:10px;text-align:center;"><strong style="color:blue;">※※※※※※</strong> 大道至简(~(@^_^@)~) <strong style="color:blue;">※※※※※※</strong></div>

<hr>
]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Javase</tag>
        <tag>计算机语言</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>03-Java语言概述</title>
    <url>/2024/06/15/javase/03-Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者: 夜泊1990</span><br><span class="line">企鹅: 1611756908</span><br><span class="line">鹅群: 948233848</span><br><span class="line">邮箱: hd1611756908@163.com</span><br><span class="line">博客: https://hd1611756908.github.io/</span><br><span class="line">B 站: https://space.bilibili.com/514155929/</span><br></pre></td></tr></table></figure>

<h2 id="第一章-Java语言发展史"><a href="#第一章-Java语言发展史" class="headerlink" title="第一章 Java语言发展史"></a>第一章 Java语言发展史</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">硬件的发展 -- 廉价的单片式微控制器 -- 用于智能化家居</span><br><span class="line"></span><br><span class="line">1991年成立Green小组(詹姆斯·高斯林任组长),专攻计算机在家电领域的嵌入式应用</span><br><span class="line">1992年夏Oak开发成功(根据C++语言改造),Oak开发成功之后需要硬件厂家支持,但是硬件厂家没同意(因为Oak没人用,硬件厂商怕支持了没人买)Oak直接凉了</span><br><span class="line">1995年互联网蓬勃发展,那时候需要一种语言可以在网络上传输,并且给页面增加动态效果,Green小组成员发现Oak可以完成这样的要求,并且当初设计的时候这门语言也比较小适合在网络上传输,所以对Oak语言一顿修改,重命名为Java,并且在Sun World大会上亮相被认可(IBM,微软,HP..)</span><br><span class="line">1996年1月 Sun公司发布了Java的第一个开发工具包（JDK1.0）</span><br><span class="line">1997年2月 JDK1.1</span><br><span class="line">1999年6月 JDK1.2</span><br><span class="line">	J2ME（Java2 Micro Edition Java2平台的微型版）应用于嵌入式、无线领域</span><br><span class="line">	J2SE（Java2 Standard Edition Java2平台的标准版）应用于桌面环境,现在已经被Android应用和IOS应用取代</span><br><span class="line">	J2EE（Java2 Enterprise Edition Java2平台的企业版）应用于基于Java的应用服务器,以后的学习方向</span><br><span class="line">2000年5月 JDK1.3、JDK1.4</span><br><span class="line">2004年9月 JDK5(从原来的1.x版本修改成x版本) 里程碑版本,增加了很多实用功能</span><br><span class="line">2005年6月 JDK6</span><br><span class="line">2009年    甲骨文(Oracle)公司宣布收购Sun</span><br><span class="line">2011年    JDK7</span><br><span class="line">2014年    JDK8(JDK8版本开始部分收费 JDK8u211及以上版本开始收费,以下版本依然免费) 当前国内使用的版本</span><br><span class="line">2017年9月 JDK9 收费</span><br><span class="line">2018年3月 JDK10 收费</span><br><span class="line">...</span><br><span class="line">2021年    JDK16 收费</span><br><span class="line">2021年    JDK17 免费</span><br><span class="line">...</span><br><span class="line">          JDK19 免费</span><br><span class="line">2023年	 JDK20</span><br><span class="line">...        </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="第二章-Java语言优势"><a href="#第二章-Java语言优势" class="headerlink" title="第二章 Java语言优势"></a>第二章 Java语言优势</h2><h3 id="第1节-Java语言应用方向"><a href="#第1节-Java语言应用方向" class="headerlink" title="第1节 Java语言应用方向"></a>第1节 Java语言应用方向</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Java语言的职业方向</span><br><span class="line">1. Android系统应用早期是用Java语言开发的,当然现在也可以使用,不过现在有替代语言Kotlin</span><br><span class="line">2. 很多大数据相关框架都是使用Java语言开发的,比如hadoop，Hbase，Elasticsearch等</span><br><span class="line">3. 在应用领域很多软件的后台服务都是基于Java开发</span><br><span class="line">	3.1 电商领域(淘宝、京东...)</span><br><span class="line">	3.2 金融领域(支付宝、银行...)</span><br><span class="line">	3.3 软件工具(Eclipse...)</span><br><span class="line">	3.4 国内的各个领域(政府、金融、保险、医疗、教育...)Java占着举足轻重的地位</span><br><span class="line"></span><br><span class="line">打开我们的手机,里面的APP软件大部分后台都是Java语言编写的.</span><br></pre></td></tr></table></figure>

<h3 id="第2节-Java语言自身特点"><a href="#第2节-Java语言自身特点" class="headerlink" title="第2节 Java语言自身特点"></a>第2节 Java语言自身特点</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. 简单性</span><br><span class="line">2. 面向对象</span><br><span class="line">3. 分布性</span><br><span class="line">4. 健壮性</span><br><span class="line">5. 安全性</span><br><span class="line">6. 跨平台</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="第三章-Java语言的环境搭建"><a href="#第三章-Java语言的环境搭建" class="headerlink" title="第三章 Java语言的环境搭建"></a>第三章 Java语言的环境搭建</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Java语言属于高级语言,采用Java语言编写的程序,计算机是不能直接运行的,这时候需要一个语言翻译(编译)工具,翻译成机器可以识别的机器码才可以.</span><br><span class="line"></span><br><span class="line">Java官方提供了JDK(Java Development Kit)Java开发工具包,工具包中包含了开发Java语言的各种工具(包含语言编译工具)以及运行Java软件的环境等</span><br></pre></td></tr></table></figure>

<ul>
<li>下载地址</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">https://www.oracle.com/java/technologies/downloads/</span><br></pre></td></tr></table></figure>

<ul>
<li>安装</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">傻瓜式安装</span><br><span class="line">注意: 安装路径不能有中文,不能有空格,不需要额外安装jre(Java运行时环境)</span><br></pre></td></tr></table></figure>

<ul>
<li>安装目录介绍</li>
</ul>
<table>
    <tr>
        <td> <img src="https://note.youdao.com/yws/api/personal/file/WEB46e65b155fd784526a889d04673cf545?method=download&shareKey=9c57ce9c71cabbbfb0ad318b8d164027"> </td>
    </tr>
    <tr>
        <td> <img src="https://note.youdao.com/yws/api/personal/file/WEB6fcb67dc62b4622f59bb2d8c755176c4?method=download&shareKey=43b8f42212b4cf094cfa7cc9035e01b0"> </td>
    </tr>
</table>

<ul>
<li>环境变量配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. 设置变量 JAVA_HOME=JDK安装路径,精确到bin目录的上一级</span><br><span class="line">2. 将JAVA_HOME添加到Path路径下 %JAVA_HOME%\bin;</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1. JAVA_HOME 必须全部大写</span><br><span class="line">2. JAVA_HOME 两个单词中间是下划线而非减号</span><br><span class="line">3. %XXX% 百分号是windows系统中取变量值的一种语法 </span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">在DOS命令行窗口中执行 java -version 命令. 如果打印出jdk的版本,说明安装成功.</span><br></pre></td></tr></table></figure>

<h2 id="第四章-第一个Java软件编写"><a href="#第四章-第一个Java软件编写" class="headerlink" title="第四章 第一个Java软件编写"></a>第四章 第一个Java软件编写</h2><h3 id="第1节-开发工具介绍"><a href="#第1节-开发工具介绍" class="headerlink" title="第1节 开发工具介绍"></a>第1节 开发工具介绍</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Windows自带的文本文档              免费(功能较少)</span><br><span class="line">notepad++ (后改名为 notepad-plus)  免费</span><br><span class="line">SublimeText                       收费</span><br><span class="line">Eclipse                           免费</span><br><span class="line">IntelliJ IDEA                     收费</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="第2节-Java代码编写步骤"><a href="#第2节-Java代码编写步骤" class="headerlink" title="第2节 Java代码编写步骤"></a>第2节 Java代码编写步骤</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. 创建一个文本文件,文件的格式以.java结尾(这里为了能看清你电脑上每一个文件的格式,需要将文件后缀名设置出来.)</span><br><span class="line">2. 文件的名字理论上可以随意命名,但是这里强调不能使用中文,只能使用 0-9、a-z、A-Z、_、$ 不能使用其他</span><br><span class="line">3. 文件名字不能以数字开头</span><br><span class="line">4. 在给文件起名字时,英文单词的首字母必须大写,多英文单词的时候首字母也一定要大写 eg: XxxYyyZzz</span><br></pre></td></tr></table></figure>

<h3 id="第3节-代码编写"><a href="#第3节-代码编写" class="headerlink" title="第3节 代码编写"></a>第3节 代码编写</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第五章-软件的运行流程"><a href="#第五章-软件的运行流程" class="headerlink" title="第五章 软件的运行流程"></a>第五章 软件的运行流程</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. 首先Java语言是高级语言,高级语言编写的代码是不能直接被计算机解析和运行的(计算机只认识0和1)</span><br><span class="line">2. 所以首先就是对我们编写的代码进行处理(编译),处理成可以被计算机认识的形式</span><br><span class="line">3. 编译 javac XxxYyyZzz.java 将.java的源文件编译成XxxYyyZzz.class字节码文件</span><br><span class="line">4. 运行 java XxxYyyZzz  -- 将其加载到JVM虚拟机的内存中由CPU解析和运行</span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td>
            <img src="https://note.youdao.com/yws/api/personal/file/WEB4cf28e123fcaf24959991d947af085f6?method=download&shareKey=9a37def37a7dbd7751c14799b6abd74c">
        </td>
    </tr>
</table>

<h2 id="第六章-Java语言注释"><a href="#第六章-Java语言注释" class="headerlink" title="第六章 Java语言注释"></a>第六章 Java语言注释</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">什么是注释: 标注计算机代码,起到解释说明作用,给程序员(软件开发者)看的.</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//单行注释</span><br><span class="line">/* </span><br><span class="line"> * 多行注释</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * 文档型注释/多行注释/Java语言独有的</span><br><span class="line"> */</span><br><span class="line">jdk提供了对文档注释的操作使用javadoc命令可以生成java文档</span><br><span class="line">eg: </span><br><span class="line">javadoc  -d C:\Users\Administrator\Desktop\d  -encoding utf-8  HelloWorld.java</span><br></pre></td></tr></table></figure>

<hr>
<div style="font-size:10px;text-align:center;"><strong style="color:blue;">※※※※※※</strong> 大道至简(~(@^_^@)~) <strong style="color:blue;">※※※※※※</strong></div>

<hr>
]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Javase</tag>
      </tags>
  </entry>
</search>
